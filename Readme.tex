\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{listings,import}
\usepackage{algorithm}
\usepackage{algpseudocode}

\input{AAdef}
\usepackage{xcolor,tcolorbox}
\usepackage{geometry}
\geometry{margin=1in}

\lstset{
    language=Mathematica,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true,
    frame=single
}

\title{EpidCRN Package  Documentation}
\author{Team}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\section{Package Overview}

\textbf{EpidCRN} is a Mathematica package for epidemiological models (ME) (whose definition assumes the existence of a unique disease-free boundary fixed point =DFE), which aims to use also Chemical Reaction Network Theory (CRNT) methods.
Models are entered as a pair formed by the  reactions "RN", (which do not depend on the form of the rates), and their rates "rts". The first could be viewed as a definition/standardization of the model, and the second as a secondary feature, which may be chosen as polynomial (mass-action), or  fractional, at the convenience of the author, and depending
on the availability of data.


The main object of study are models with possibly several boundary fixed points 
besides the DFE (or minimal siphons, in CRN terminology), which we call multi-strain.  The focus of our package is somewhat different than that of other similar packages, a major concern being  the flexibility of operating symbolically whenever this is possible (this is a major concern in ME).Once the model is input,   anything should be achievable, at the usual cost. For example,  rational computations of $R_0$ are achieved instantaneously (for multi-strains, this is the max of individual $R_i$ for each strain), but small non-rational $R_0$ may require further effort.  Also, invasion numbers, which appear in stability conditions for the non DFE  boundary fixed points, are instantaneous if rational, but  may require work from the user, if the "siphon"  boundary fixed points are not rational.  Numeric stability scans are also available, in cases where stability is not symbolic, but the user needs to adjust various tolerances, to make this work. In summary, the package aims to provide trivial computations and also less trivial ones, but the latter are at the cost of extra user's time.


\section{Package Structure}

\subsection{Modular Organization}
The package is split into subpackages:

\begin{enumerate}
\item \texttt{EpidCRN.wl} - Main loader package, which contains all the usage statements. The following subpackages are all in the same directory with the loader.
\item \texttt{Core.wl} - Basic network analysis (\texttt{EpidCRN`Core`})
\item \texttt{CRNT.wl} - Chemical reaction network theory (\texttt{EpidCRN`CRNT`})
\item \texttt{Boundary.wl} - NGM and boundary analysis (\texttt{EpidCRN`Boundary`})
\item \texttt{Bifurcation.wl} - Hopf bifurcations and parameter scanning (\texttt{EpidCRN`Bifurcation`})
\item \texttt{Siphons.wl} - Siphon and persistence analysis (\texttt{EpidCRN`Siphons`})
\item \texttt{Utils.wl} - Utility functions (\texttt{EpidCRN`Utils`})
\item \texttt{Visualization.wl} - (\texttt{EpidCRN`Visualization`})
\end{enumerate}

\subsection{Dependency Chain}
\texttt{Core} $\rightarrow$ \texttt{CRNT} $\rightarrow$ \texttt{Boundary} $\rightarrow$ \texttt{Bifurcation} $\rightarrow$ \texttt{Siphons}

\section{Fundamental Functions Reference}

\subsection{Core Functions (EpidCRN`Core`)}

\subsubsection{extMat[reactions]}
Master function extracting network structure.

\textbf{Returns:} \{species, $\alpha$, $\beta$, $\gamma$, $R_v$, RHS, deficiency\}
\begin{enumerate}
\item \textbf{species}: List of species names as strings
\item $\alpha$: Reactant stoichiometric matrix
\item $\beta$: Product stoichiometric matrix
\item $\gamma$: Net stoichiometric matrix ($\beta - \alpha$)
\item $R_v$: Rate vector template
\item \textbf{RHS}: Right-hand side of ODE system
\item \textbf{deficiency}: Network deficiency information
\end{enumerate}

\subsubsection{asoRea[RN]}
Converts reaction network to association format.

\textbf{Input:} \texttt{RN = \{"s"+"i"->2"i", "i"->"r", "r"->"s"\}}\\
\textbf{Returns:} Association with "Substrates"/"Products" keys

\subsubsection{compToAsso[side]}
Parses reaction side to association of species $\rightarrow$ coefficients.

\subsubsection{extSpe[reactions]}
Extracts species list from reaction network.

\subsection{Siphon Analysis (EpidCRN`Siphons`)}

\subsubsection{minSiph[species, asoReactions]}
\textbf{CRITICAL FUNCTION:} Computes minimal siphons (sets of species that become zero at DFE).

\textbf{Input:}
\begin{enumerate}
\item \texttt{species}: List of species names as strings
\item \texttt{asoReactions}: Output of \texttt{asoRea[RN]}
\end{enumerate}

\textbf{Returns:} List of lists of species names as strings\\
\textbf{Example:} \texttt{\{\{"x2"\}, \{"B1","S1"\}, \{"B2","S2"\}\}}

\begin{verbatim}
{spe, al, be, gam, Rv, RHS, def} = extMat[RN];
mS = minSiph[spe, asoRea[RN]];
(* mS contains variable names, NOT indices *)
\end{verbatim}

\textbf{Critical Note:} \texttt{minSiph} returns variable names as strings. Do NOT convert to indices in downstream functions.

\subsection{CRNT Functions (EpidCRN`CRNT`)}

\subsubsection{getComE[RN\_List]}
Extract complexes and edges from reaction network.

\begin{lstlisting}
getComE[RN_List] := Module[{complexes, edges},
  complexes = {};
  edges = {};
  Do[
    Module[{left, right},
      left = RN[[i, 1]];
      right = RN[[i, 2]];
      If[! MemberQ[complexes, left], AppendTo[complexes, left]];
      If[! MemberQ[complexes, right], AppendTo[complexes, right]];
      AppendTo[edges, {left, right}];
    ],
    {i, Length[RN]}
  ];
  {complexes, edges}
];
\end{lstlisting}

\textbf{Input:} Reaction network as list of \{left, right\} pairs\\
\textbf{Returns:} \texttt{\{complexes, edges\}}\\
\textbf{Example:} \texttt{getComE[\{\{a,b\},\{b,c\},\{c,a\}\}]} $\rightarrow$ \texttt{\{\{a, b, c\}, \{\{a, b\}, \{b, c\}, \{c, a\}\}\}}

\subsubsection{IaFHJ[vert\_, edg\_]}
Incidence matrix analysis for FHJ graphs.

\begin{lstlisting}
IaFHJ[vert_, edg_] := Module[{gg, oU, taF},
  gg[a_, b_] := Which[
    a === b[[1]], -1,
    a === b[[2]], 1,
    True, 0
  ];
  oU = Table[
    gg[vert[[i]], edg[[j]]],
    {i, Length[vert]},
    {j, Length[edg]}
  ];
  taF = TableForm[
    oU,
    TableHeadings -> {vert, edg},
    TableAlignments -> {Right, Top}
  ];
  {oU, taF}
];
\end{lstlisting}

\textbf{Input:} Vertices and edges lists\\
\textbf{Returns:} \texttt{\{matrix (n\_complexes $\times$ n\_reactions), tableForm\}}

\subsubsection{IkFHJ[vert\_, edg\_, tk\_]}
Ik matrix computation for FHJ analysis.

\begin{lstlisting}
IkFHJ[vert_, edg_, tk_] := Module[{tri, gg, oU},
  tri = MapThread[Append, {edg, tk}];
  gg[a_, b_] := Which[
    a === b[[1]], b[[3]],
    a === b[[2]], 0,
    True, 0
  ];
  oU = Table[
    gg[vert[[i]], tri[[j]]],
    {i, Length[vert]},
    {j, Length[tri]}
  ] // Transpose
];
\end{lstlisting}

\textbf{Input:} Vertices, edges, and rate constants\\
\textbf{Returns:} Matrix (n\_reactions $\times$ n\_complexes)

\subsubsection{SpeComInc[spec\_, comp\_]}
Species-complex incidence matrix.

\begin{lstlisting}
SpeComInc[spec_, comp_] := Coefficient[#, spec] & /@ comp;
\end{lstlisting}

\textbf{Input:} Species list and complexes list\\
\textbf{Returns:} Coefficient matrix\\
\textbf{Example:} \texttt{SpeComInc[\{x, y\}, \{x + y, 2 x, y\}]} $\rightarrow$ \texttt{\{\{1, 1\}, \{2, 0\}, \{0, 1\}\}}

\subsubsection{lapK[RN\_, rates\_]}
Main Laplacian computation function.

\begin{lstlisting}
lapK[RN_, rates_] := Module[{complexes, edges, laplacian},
  {complexes, edges} = getComE[RN];
  laplacian = IkFHJ[complexes, edges, rates];
  laplacian
];
\end{lstlisting}

\textbf{Input:} Reaction network and rate constants\\
\textbf{Returns:} Laplacian matrix (n\_complexes $\times$ n\_complexes)

\section{Boundary Analysis Functions}

\subsection{NGM[mod, inf]}
Next Generation Matrix analysis.

\textbf{Input:}
\begin{enumerate}
\item \texttt{mod}: \texttt{\{RHS, var, par\}}
\item \texttt{inf}: List of infected compartment indices
\end{enumerate}

\textbf{Returns:} \texttt{\{Jx, Jy, ..., K, ...\}} where \texttt{K = ngm[[4]]} is the transmission matrix

\subsection{Current Session Work: Enhanced Boundary Analysis Modules}

\subsubsection{bdAn[RN, rts] - Simplified Analysis Module}
Core analysis without boundary fixed point computation.

\begin{lstlisting}
bdAn[RN_, rts_] := Module[{
    spe, al, be, gam, Rv, RHS, def, var, par, cp, cv, ct,
    mSi, mSiIndices, inf, mod, K, eig, R0A, cDFE, RDFE, eq0, var0, E0,
    Jx, Jy, eigenSystem, eigenvals, eigenvecs, nonzeroIndices,
    relevantEigenvals, strainAssociation, sortedPairs, mSiNGM,
    ngm
   },

   {spe, al, be, gam, Rv, RHS, def} = extMat[RN];
   var = ToExpression[spe];
   RHS = gam . rts;
   par = Par[RHS, var];
   cp = Thread[par > 0];
   cv = Thread[var >= 0];
   ct = Join[cp, cv];

   (* Direct assignment - mSi contains variable names as strings *)
   mSi = minSiph[spe, asoRea[RN]];
   mSiIndices = Map[Flatten[Position[spe, #] & /@ #] &, mSi]; (* Indices for NGM *)
   inf = Union[Flatten[mSiIndices]];

   (* Compute DFE *)
   cDFE = Flatten[Thread[ToExpression[#] -> 0] & /@ mSi];
   RDFE = RHS /. cDFE;
   eq0 = Thread[RDFE == 0];
   var0 = Complement[var, var[[inf]]];
   E0 = Join[Solve[eq0, var0] // Flatten, Thread[var[[inf]] -> 0]];

   (* Compute NGM *)
   mod = {RHS, var, par};
   ngm = NGM[mod, inf];
   Jx = ngm[[1]] // FullSimplify;
   Jy = ngm[[5]] // FullSimplify;
   K = ngm[[4]] // FullSimplify;

   (* Get eigenvalues and organize by strain *)
   eigenSystem = Eigensystem[K];
   eigenvals = eigenSystem[[1]];
   eigenvecs = eigenSystem[[2]];
   nonzeroIndices = {};
   Do[If[eigenvals[[i]] =!= 0, AppendTo[nonzeroIndices, i]],
      {i, Length[eigenvals]}];

   If[Length[nonzeroIndices] > 0,
    relevantEigenvals = eigenvals[[nonzeroIndices]];
    mSiNGM = Table[Flatten[Table[Position[inf, mSiIndices[[i]][[j]]][[1,1]],
      {j, Length[mSiIndices[[i]]]}]], {i, Length[mSiIndices]}];
    strainAssociation = Table[Module[{strain1Nonzeros, strain2Nonzeros, evec},
       evec = eigenvecs[[nonzeroIndices[[i]]]];
       strain1Nonzeros = Count[evec[[mSiNGM[[1]]]], Except[0]];
       strain2Nonzeros = Count[evec[[mSiNGM[[2]]]], Except[0]];
       If[strain1Nonzeros > strain2Nonzeros, 1,
        If[strain2Nonzeros > strain1Nonzeros, 2, i]]],
       {i, Length[relevantEigenvals]}];
    sortedPairs = Sort[Transpose[{strainAssociation, relevantEigenvals}]];
    R0A = sortedPairs[[All, 2]];,
    R0A = {};];

   {RHS, var, par, cp, mSi, Jx, Jy, E0, K, R0A}
]
\end{lstlisting}

\textbf{Returns:} \texttt{\{RHS, var, par, cp, mSi, Jx, Jy, E0, K, R0A\}}

\section{bdFp Module Usage Guide}

\subsection{Purpose}
\texttt{bdFp} computes boundary fixed points on siphon facets for epidemic models, separating rational solutions from algebraic ones and providing scalar elimination equations for non-rational cases.

\subsection{Syntax}
\begin{lstlisting}
bdfpT = bdFp[RHS, var, mSi]
\end{lstlisting}

\subsection{Parameters}

\subsubsection{Required Inputs}
\begin{enumerate}
\item \textbf{RHS}: Right-hand side vector of the ODE system (from \texttt{bdAn})
\item \textbf{var}: List of all variables as symbols (from \texttt{bdAn})
\item \textbf{mSi}: Minimal siphons as variable names (strings) (from \texttt{bdAn})
\end{enumerate}

\subsection{Output Format}
Returns a list of pairs, one for each siphon facet:
\begin{lstlisting}
{
  {rationalSols1, scalarEq1},
  {rationalSols2, scalarEq2},
  ...
}
\end{lstlisting}

\subsubsection{Output Components}
\begin{enumerate}
\item \textbf{rationalSols}: List of rational solutions (rules like \texttt{\{x -> value, y -> value\}})
\item \textbf{scalarEq}:
\begin{enumerate}
\item \texttt{None} if all solutions are rational
\item Factored polynomial equation if non-rational solutions exist
\item \texttt{"froze"} if computation timed out
\end{enumerate}
\end{enumerate}

\subsection{Example Usage}

\subsubsection{Basic Usage}
\begin{lstlisting}
(* Get core analysis, pass var and gam to preserve order *)
{RN, rts, spe, alp, bet, gam} = ODE2RN[RHS1, var];
{RHS, var, par, cp, mSi, Jx, Jy, cDFE, E0, K, R0A, infVars, ngm} = bdAn[RN, rts, var, gam];

(* Compute boundary fixed points *)
bdfpT = bdFp[RHS, var, mSi];

(* Extract results for each facet *)
facet1Results = bdfpT[[1]];  (* {rationalSols, scalarEq} for first siphon *)
facet2Results = bdfpT[[2]];  (* {rationalSols, scalarEq} for second siphon *)
\end{lstlisting}

\subsubsection{Accessing Results}
\begin{lstlisting}
(* Get rational solutions for facet 1 *)
rationalSols1 = bdfpT[[1]][[1]];

(* Get scalar equation for facet 1 (if any) *)
scalarEq1 = bdfpT[[1]][[2]];

(* Check if facet has only rational solutions *)
If[bdfpT[[2]][[2]] === None,
  Print["Facet 2 has only rational solutions"],
  Print["Facet 2 has algebraic solutions satisfying: ", bdfpT[[2]][[2]]]
];
\end{lstlisting}

\subsection{Example Output}

\subsubsection{Console Output}
\begin{verbatim}
bdFp finds the fixed points on siphon facets are
fps on siphon facet {i1} are {{i_2->0, s->\Lambda/(\mu+\rho), v_1->(\Lambda\rho)/(\mu(\mu+\rho))}},
and 2 more fps satisfying the scalar equation i_2^2(\beta_v\gamma_2 + \mu)(\beta_2 i_2 - \Lambda + \mu) == 0
fps on siphon facet {i2} are {{rational solution 1}, {rational solution 2}}
\end{verbatim}

\subsubsection{Return Value}
\begin{lstlisting}
{
  {
    {{i_2->0, s->\Lambda/(\mu+\rho), v_1->(\Lambda\rho)/(\mu(\mu+\rho))}},
    i_2^2(\beta_v\gamma_2 + \mu)(\beta_2 i_2 - \Lambda + \mu) == 0
  },
  {
    {{solution1}, {solution2}},
    None
  }
}
\end{lstlisting}

\subsection{Interpretation Guide}

\subsubsection{Rational Solutions}
\begin{enumerate}
\item Direct algebraic expressions in terms of parameters
\item Can be used immediately for analysis
\item Represent equilibria with explicit formulas
\end{enumerate}

\subsubsection{Scalar Equations}
\begin{enumerate}
\item Factored polynomial constraints for non-rational solutions
\item Polynomial degree indicates number of solutions
\item Factors reveal mathematical structure
\item Solutions involve radicals, roots, or complex expressions
\end{enumerate}

\subsubsection{Special Cases}
\begin{enumerate}
\item \textbf{"froze"}: Computation exceeded 10-second timeout
\item \textbf{None}: All solutions are rational (no scalar equation needed)
\item \textbf{Empty rational list \{\}}: All solutions are non-rational
\end{enumerate}

\subsection{Common Workflow}

\begin{lstlisting}
(* 1. Load model and get core analysis *)
{RHS, var, par, cp, mSi, Jx, Jy, cDFE, E0, K, R0A, infVars, ngm} = bdAn[RN, rts];

(* 2. Compute boundary fixed points *)
bdfpT = bdFp[RHS, var, mSi];

(* 3. Extract and analyze results *)
Do[
  {rationalSols, scalarEq} = bdfpT[[i]];
  Print["Siphon ", i, ":"];
  Print["  Rational solutions: ", Length[rationalSols]];
  If[scalarEq =!= None,
    Print["  Non-rational solutions satisfy: ", scalarEq];
  ];
, {i, Length[bdfpT]}];

(* 4. Use rational solutions for further analysis *)
rationalEquilibria = Flatten[bdfpT[[All, 1]], 1];
\end{lstlisting}

\subsection{Error Handling}

\subsubsection{Timeout Protection}
\begin{enumerate}
\item 10-second timeout for main \texttt{Solve} operation
\item 3-second timeout for elimination step
\item Returns \texttt{"froze"} for timed-out computations
\end{enumerate}

\subsubsection{Common Issues}
\begin{enumerate}
\item \textbf{Empty results}: Check that \texttt{mSi} contains valid siphon names
\item \textbf{All "froze"}: System may be too complex; try simpler parameter values
\item \textbf{No scalar equation}: Normal if all solutions are rational
\end{enumerate}

\subsection{Integration with bdAn/bd2}

\subsubsection{With bdAn (Core Analysis)}
\begin{lstlisting}
coreResults = bdAn[RN, rts];
{RHS, var, par, cp, mSi, Jx, Jy, cDFE, E0, K, R0A, infVars, ngm} = coreResults;
bdfpT = bdFp[RHS, var, mSi];
\end{lstlisting}

\subsubsection{With bd2 (Complete Analysis)}
\begin{lstlisting}
fullResults = bd2[RN, rts];
{RHS, var, par, cp, mSi, Jx, Jy, E0, ngm, R0A, EA, bdfpT} = fullResults;
(* bdfpT already computed by bd2 *)
\end{lstlisting}

\subsection{Performance Notes}
\begin{enumerate}
\item Runtime scales with system complexity and siphon count
\item Elimination step may be slow for high-dimensional systems
\item Factorization improves readability but adds computational cost
\item Consider using \texttt{bdAn} alone for preliminary analysis if speed is critical
\end{enumerate}



\subsubsection{bd2[RN, rts] - Complete Analysis Module}
Complete analysis combining bdAn + bdFp.

\begin{lstlisting}
bd2[RN_, rts_] := Module[{
    coreResults, RHS, var, par, cp, mSi, Jx, Jy, E0, ngm, R0A,
    bdfpT, EA
   },

   (* Get core analysis from bdAn *)
   coreResults = bdAn[RN, rts];
   {RHS, var, par, cp, mSi, Jx, Jy, E0, ngm, R0A} = coreResults;

   (* Compute boundary fixed points using bdFp with timeout protection *)
   bdfpT = bdFp[RHS, var, mSi];

   (* Create EA structure for backward compatibility *)
   EA = Table[
     Module[{siphonVars, remainingVars},
       siphonVars = ToExpression[mSi[[j]]];
       remainingVars = Complement[var, siphonVars];
       {Thread[RHS /. Thread[siphonVars -> 0] == 0], remainingVars}
     ], {j, Length[mSi]}];

   (* Return complete results *)
   {RHS, var, par, cp, mSi, Jx, Jy, E0, ngm, R0A, EA, bdfpT}
]
\end{lstlisting}

\textbf{Returns:} \texttt{\{RHS, var, par, cp, mSi, Jx, Jy, E0, ngm, R0A, EA, bdfpT\}}

\section{Invasion Graph Theory Implementation}

\subsection{Theoretical Foundation}

Invasion graphs provide a framework for understanding global dynamics of multi-strain epidemic systems by mapping which strains can invade established equilibria. This connects the Lotka-Volterra invasion graph theory of Almaraz et al. with epidemiological invasion numbers.

\subsection{Key Definitions}

\subsubsection{Admissible Communities}
For epidemic models, an admissible community corresponds to a biologically meaningful endemic state where certain strains are present.

\subsubsection{Invasion Rates}
For community $I$ with equilibrium $\mathbf{u}^*$, the invasion rate of strain $j \notin I$ is:
$$r_j(I) = b_j + \sum_{k \in I} a_{jk} u_k^*$$

\subsubsection{Invasion Numbers (Epidemic Context)}
For Rahman-type models:
$$R_j^{(i)} = \mathcal{R}_j \times s_i$$
where $\mathcal{R}_j = \beta_j/\nu_j$ and $s_i$ is susceptible level at equilibrium $i$.

\subsection{Equivalence Theorem}

\textbf{Key Result:} LV invasion rates and epidemic invasion numbers are equivalent:
$$r_j^{\text{LV}}(I) = \nu_j(R_j^{(i)} - 1)$$

\textbf{Sign Correspondence:}
\begin{align}
r_j^{\text{LV}}(I) > 0 &\Leftrightarrow R_j^{(i)} > 1 \quad \text{(successful invasion)}\\
r_j^{\text{LV}}(I) < 0 &\Leftrightarrow R_j^{(i)} < 1 \quad \text{(failed invasion)}
\end{align}

\subsection{Implementation Algorithm}

\begin{lstlisting}
invasionGraph[RHs_, var_, par_, mSi_] := Module[{
    communities, invasionRates, edges
   },

   (* 1. Identify all admissible communities *)
   communities = findAdmissibleCommunities[RHS, var, mSi];

   (* 2. For each community, compute invasion rates *)
   invasionRates = Table[
     computeInvasionRates[RHS, var, communities[[i]]],
     {i, Length[communities]}];

   (* 3. Construct edges based on invasion success *)
   edges = {};
   Do[
     invasiveSets = Position[invasionRates[[i]], _?Positive];
     Do[AppendTo[edges, communities[[i]] -> communities[[j]]],
        {j, invasiveSets}];,
     {i, Length[communities]}];

   {communities, invasionRates, edges}
]
\end{lstlisting}

\subsection{Rahman Model Implementation}

\begin{lstlisting}
rahmanInvasionGraph[E1t_, E2t_, R0A_, E0_] := Module[{
    R01, R02, R12, R21, S1, S2, invasionMatrix
   },

   (* Extract basic reproduction numbers *)
   {R01, R02} = R0A /. E0;

   (* Extract susceptible levels at single-strain equilibria *)
   S1 = (* Extract S level from E1t *);
   S2 = (* Extract S level from E2t *);

   (* Compute invasion numbers *)
   R12 = R0A[[1]] /. E2t; (* Strain 1 invading strain 2 *)
   R21 = R0A[[2]] /. E1t; (* Strain 2 invading strain 1 *)

   (* Construct invasion graph based on thresholds *)
   invasionMatrix = {
     {"DFE", If[R01 > 1, "E1", ""], If[R02 > 1, "E2", ""]},
     {"E1", "", If[R12 > 1, "Coexistence", ""]},
     {"E2", If[R21 > 1, "Coexistence", ""], ""}
   };

   {R01, R02, R12, R21, invasionMatrix}
]
\end{lstlisting}

\section{Bifurcation Analysis Functions}

\subsection{fpHopf[RHS, var, par, p0val]}
Fixed point finder with Hopf analysis.

\textbf{Returns:} \texttt{\{posSols, complexEigs, angle, eigs\}}
\begin{enumerate}
\item \textbf{angle}: \texttt{ArcTan[Re/Im]*180/Pi} (negative = stable focus, positive = Hopf)
\end{enumerate}

\subsection{Parameter Space Scanning Functions}

\subsubsection{scan Function}
The \texttt{scan} function represents the most sophisticated parameter scanning approach:

\begin{verbatim}
{finalPlot, noSolPoints, results} = scan[RHS, var, par, persRule, plotInd,
  mSi, gridRes, steadyTol, stabTol, chopTol, R01, R02, R12, R21]
\end{verbatim}

\textbf{Key Features:}
\begin{enumerate}
\item Automatic variable detection from minimal siphons (\texttt{mSi})
\item Dual scanning modes: Grid mode (fixed resolution) and range mode (adaptive stepping)
\item Comprehensive equilibrium classification: DFE, E1, E2, EE-Stable, EE-Unstable, NoSol
\item Reproduction number integration with R-curve overlays
\item Robust numerical methods with timeouts and error handling
\end{enumerate}

\subsubsection{scanPar Function}
Simpler, more direct scanning approach:

\begin{verbatim}
{finalPlot, errors, results} = scanPar[RHS, var, par, p0val, plotInd,
  gridRes, plot, hTol, delta, wRan, hRan, R01, R02, R21, R12]
\end{verbatim}

\section{Critical Usage Notes}

  \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Critical Variable Handling Rules]
\begin{enumerate}
    \item \textbf{mSi contains variable names as strings}, not indices
    \item Species names should be strings ("s", "i1", "i2")
    \item Use \texttt{ToExpression[mSi[[j]]]} to convert to symbols when needed
    \item NEVER convert \texttt{mSi} to indices in \texttt{bdAn} or related functions
\end{enumerate}
\end{tcolorbox}

\subsection{Matrix Conventions}
\begin{enumerate}
\item $\alpha$: reactant stoichiometric matrix (species $\times$ reactions)
\item $\beta$: product stoichiometric matrix
\item $\gamma = \beta - \alpha$: net stoichiometric matrix
\item Laplacian follows CRNT convention (column sums = 0)
\end{enumerate}

\subsection{Function Compatibility}
\begin{enumerate}
\item Functions expect exact expression matching using \texttt{===} operator
\item Most functions return lists, not associations
\item Always use timeout protection for \texttt{Solve} operations in boundary analysis
\item Check for rational solutions using \texttt{FreeQ[sol, Sqrt | Power[\_, Except[\_Integer]] | Root | \_Complex]}
\end{enumerate}

\section{Complete Analysis Workflow}

\begin{lstlisting}
(* 1. Load package *)
<< EpidCRN`;

(* 2. Define model *)
RN = {0 -> "s", "s" + "i1" -> 2*"i1", "s" + "i2" -> 2*"i2",
      "s" -> 0, "i1" -> 0, "i2" -> 0};
rts = {La, be1*s*i1/(1+a1*i1), be2*s*i2/(1+a2*i2),
       mu*s, (mu+ga1)*i1, (mu+ga2)*i2};

(* 3. Core analysis (fast, no boundary points) *)
{RHS, var, par, cp, mSi, Jx, Jy, cDFE, E0, K, R0A, infVars, ngm} = bdAn[RN, rts];

(* 4. Complete analysis (with boundary points and timeout protection) *)
{RHS, var, par, cp, mSi, Jx, Jy, E0, ngm, R0A, EA, bdfpT} = bd2[RN, rts];

(* 5. Extract reproduction numbers *)
{R01, R02} = R0A /. E0;

(* 6. Parameter space analysis *)
{plot, errors, results} = scanPar[RHS, var, par, p0val, plotInd,
  30, Automatic, 0.01, 1/20, 0.5, 0.5, R01, R02, R21, R12];

(* 7. Bifurcation analysis *)
{bestAngle, bestValues, finalP0Val} =
  optHopf[RHS, var, par, coP, {3,4}, 120, "NelderMead", 4, 4, 500];

(* 8. Invasion graph construction *)
{communities, invasionRates, edges} = invasionGraph[RHS, var, par, mSi];
\end{lstlisting}

\section{File Structure}

\begin{verbatim}
EpidCRN/
    EpidCRN.wl       (main package loader)
    Core.wl          (EpidCRN`Core` context)
    CRNT.wl          (EpidCRN`CRNT` context)
    Boundary.wl      (EpidCRN`Boundary` context)
    Bifurcation.wl   (EpidCRN`Bifurcation` context)
    Siphons.wl       (EpidCRN`Siphons` context)
    Utils.wl         (EpidCRN`Utils` context)
    Visualization.wl (EpidCRN`Visualization` context)
\end{verbatim}

\textbf{Critical:} File names must match subcontext names exactly for \texttt{Get[]} to work automatically.

\section{Notes for Future Development}

\begin{enumerate}
\item This documentation preserves all fundamental functions with complete code to prevent package modification errors
\item The \texttt{mSi = mS} assignment in \texttt{bdAn} is critical - do NOT convert to indices
\item All timeout protections and rational solution filtering have been thoroughly tested
\item The invasion graph framework provides a unified approach to understanding multi-strain dynamics
\item Function compatibility and variable handling rules must be strictly followed
\end{enumerate}

\section{Antigenic Variation Models}

\subsection{Trypanosoma Model (TrypN.nb)}

\subsubsection{typAnt[RN, rts] - Trypanosoma Antigenic Variation Analysis}

\textbf{Purpose:} Analyzes two-strain Trypanosoma brucei models with antigenic variation through Variant Surface Glycoprotein (VSG) switching.

\textbf{Model Structure:}
\begin{itemize}
\item \textbf{s}: Susceptible host population
\item \textbf{i1, i2}: Infected with VSG variant 1 or 2
\item \textbf{r1, r2}: Recovered from variant 1 or 2
\item Includes recruitment, infection, recovery, death, and waning immunity
\end{itemize}

\textbf{Usage:}
\begin{lstlisting}
<< EpidCRN`;
(* Define reaction network and rates as in TrypN.nb *)
{RHS, var, par, cp, mSi, Jx, Jy, E0, K, R0A} = typAnt[RN, rts];
\end{lstlisting}

\textbf{Returns:}
\begin{enumerate}
\item \textbf{RHS}: Right-hand side of ODE system
\item \textbf{var}: Variable list \{s, i1, i2, r1, r2\}
\item \textbf{par}: Parameter list
\item \textbf{cp}: Parameter constraints (all positive)
\item \textbf{mSi}: Minimal siphons (infection compartments)
\item \textbf{Jx, Jy}: Jacobian blocks
\item \textbf{E0}: Disease-free equilibrium
\item \textbf{K}: Next generation matrix
\item \textbf{R0A}: Basic reproduction numbers for each variant
\end{enumerate}

\textbf{Key Features:}
\begin{itemize}
\item Strain-specific reproduction numbers $R_{01}, R_{02}$
\item Automatic detection of minimal siphons
\item NGM analysis for multi-strain dynamics
\item Foundation for invasion graph analysis
\end{itemize}

\subsection{Recker Model (ReckerN.nb)}

\subsubsection{recAnt[RN, rts] - Recker Antigenic Variation Analysis}

\textbf{Purpose:} Analyzes multi-strain pathogen models with antigenic variation following Recker et al. framework for malaria and other pathogens with antigenic diversity.

\textbf{Model Structure:}
\begin{itemize}
\item \textbf{s}: Susceptible population
\item \textbf{i1, i2, i3}: Infected with antigenic variant 1, 2, or 3
\item \textbf{r1, r2, r3}: Recovered with variant-specific immunity
\item Cross-immunity between variants (implicit in structure)
\item Waning immunity allowing reinfection
\end{itemize}

\textbf{Usage:}
\begin{lstlisting}
<< EpidCRN`;
(* Define 3-strain reaction network and rates as in ReckerN.nb *)
{RHS, var, par, cp, mSi, Jx, Jy, E0, ngm, R0A, EA, bdfpT} = recAnt[RN, rts];
\end{lstlisting}

\textbf{Returns:} Same as \texttt{bd2} output (complete boundary analysis):
\begin{enumerate}
\item \textbf{RHS}: ODE system right-hand side
\item \textbf{var}: Variables \{s, i1, i2, i3, r1, r2, r3\}
\item \textbf{par}: Parameters
\item \textbf{cp}: Parameter constraints
\item \textbf{mSi}: Minimal siphons (infection states)
\item \textbf{Jx, Jy}: Jacobian blocks
\item \textbf{E0}: Disease-free equilibrium
\item \textbf{ngm}: Full NGM structure
\item \textbf{R0A}: Basic reproduction numbers for variants
\item \textbf{EA}: Endemic equilibria structure
\item \textbf{bdfpT}: Boundary fixed points with rational solutions and scalar equations
\end{enumerate}

\textbf{Key Features:}
\begin{itemize}
\item Three antigenic variants with full CRNT analysis
\item Boundary fixed points on siphon facets
\item Rational and algebraic solution separation
\item Supports invasion number computation for multi-strain coexistence
\item Compatible with parameter scanning and bifurcation analysis
\end{itemize}

\subsection{Comparison: typAnt vs recAnt}

\begin{tabular}{|l|l|l|}
\hline
\textbf{Feature} & \textbf{typAnt} & \textbf{recAnt} \\
\hline
Application & Trypanosoma (VSG) & General antigenic variation \\
Number of strains & 2 & 3 (extensible) \\
Function call & Direct implementation & Wrapper for bd2 \\
Boundary points & No (uses bdAn logic) & Yes (full bd2 output) \\
Computation time & Faster & Slower (includes bdFp) \\
Use case & Quick R0 analysis & Complete equilibrium analysis \\
\hline
\end{tabular}

\subsection{Antigenic Variation Analysis Workflow}

\begin{lstlisting}
(* 1. Load package *)
<< EpidCRN`;

(* 2. Define model - use TrypN.nb or ReckerN.nb as template *)
RN = {...};  (* reaction network *)
rts = {...}; (* rate expressions *)

(* 3. For quick analysis: use typAnt *)
{RHS, var, par, cp, mSi, Jx, Jy, E0, K, R0A} = typAnt[RN, rts];
Print["R0 values: ", R0A /. E0];

(* 4. For complete analysis: use recAnt *)
{RHS, var, par, cp, mSi, Jx, Jy, E0, ngm, R0A, EA, bdfpT} = recAnt[RN, rts];
Print["Boundary equilibria: ", bdfpT];

(* 5. Invasion numbers for coexistence analysis *)
(* Extract boundary equilibria and compute invasion conditions *)
\end{lstlisting}

\subsection{Implementation Notes}

\begin{enumerate}
\item Both functions follow EpidCRN naming convention: short abbreviations returning lists
\item \texttt{typAnt} = "Trypanosoma Antigenic variation"
\item \texttt{recAnt} = "Recker Antigenic variation"
\item All outputs are lists (not associations) for consistency
\item Functions are fully documented in respective notebook files
\item Compatible with existing EpidCRN workflow (NGM, scanning, bifurcation)
\end{enumerate}

\section{Reaction Network Formats and Converters}

The EpidCRN package uses three formats for reaction networks:

\subsection{Format 1: Symbolic Format}
\textbf{Used by:} Internal computations

\textbf{Format:} Reactions use symbolic variables
\begin{lstlisting}
RN = {0 -> s, i+s -> 2*i, s -> 0, i -> 0}
\end{lstlisting}

\textbf{Characteristics:}
\begin{itemize}
\item Species are Mathematica symbols (s, i, r, etc.)
\item Sum of species: i+s (symbolic Plus)
\item Suitable for direct mathematical operations
\item Can be converted using symbToStr
\end{itemize}

\subsection{Format 2: String-Plus Format}
\textbf{Used by:} bdAn, NGM, most package functions

\textbf{Format:} String species with Plus for sums
\begin{lstlisting}
RN = {"0" -> "s", "i" + "s" -> "2i", "s" -> "0"}
\end{lstlisting}

\textbf{Characteristics:}
\begin{itemize}
\item Species are strings ("s", "i", "r", etc.)
\item Sum of species: "i" + "s" (Plus of strings)
\item Required format for bdAn, NGM, and analysis functions
\item Standard format throughout most of the package
\end{itemize}

\subsection{Format 3: Concatenated String Format}
\textbf{Used by:} Display/printing only (not functional)

\textbf{Format:} Single concatenated strings
\begin{lstlisting}
RN = {0 -> s, s+i -> 2i, s -> 0}
\end{lstlisting}

\textbf{Characteristics:}
\begin{itemize}
\item Species sums as single strings: "s+i" (not "s"+"i")
\item Not accepted by bdAn or other package functions
\item Only for display purposes
\item Must be converted to Format 2 for use
\end{itemize}

\subsection{Format Converters}

\subsubsection{symbToStr - Convert Symbolic to String Format}
\textbf{Purpose:} Converts symbolic RN (from ODE2RN) to string format for use with bdAn, NGM

\textbf{Usage:}
\begin{lstlisting}
(* Get symbolic RN from ODE2RN *)
{RN, rts, spe, alp, bet, gam} = ODE2RN[RHS, var];

(* Convert to string format for bdAn/NGM *)
RNstr = symbToStr /@ RN;

(* Now can use with bdAn *)
{RHSback, varBack, parBack, cpBack, mSiBack, JxBack, JyBack, cDFEBack, E0Back, KBack, R0ABack, infVarsBack, ngmBack} = bdAn[RNstr, rts];
\end{lstlisting}

\subsubsection{strToSymb - Convert String to Symbolic Format}
\textbf{Purpose:} Converts string-based RN to symbolic format

\textbf{Usage:}
\begin{lstlisting}
(* String format RN *)
RNstr = {"0" -> "s", "s" -> "0"};

(* Convert to symbolic *)
RNsym = strToSymb[RNstr];
\end{lstlisting}

\subsection{Workflow: ODE2RN to NGM}

To use ODE2RN output with NGM and other package functions:

\begin{lstlisting}
(* Step 1: Convert ODE to RN *)
RHS = {La - be*i*s - mu*s, be*i*s - (ga + mu)*i};
var = {s, i};
{RN, rts, spe, alp, bet, gam} = ODE2RN[RHS, var];
(* RN is already in string format, ready to use *)

(* Step 2: Use with bdAn to get model structure *)
{RHSback, varBack, parBack, cpBack, mSiBack, JxBack, JyBack, cDFEBack, E0Back, KBack, R0ABack, infVarsBack, ngmBack} = bdAn[RN, rts];
mod = {RHSback, var, parameters};

(* Step 3: Use with NGM *)
infVars = {2};  (* Index of infection variable *)
ngmResult = NGM[mod, infVars];
\end{lstlisting}

\textbf{Note:} ODE2RN now outputs RN in string format directly, so no conversion is needed.

\section{ODE to Reaction Network Conversion}

\subsection{ODE2RN - Convert ODE System to Reaction Network}

\textbf{Purpose:} Converts an ODE system to a chemical reaction network representation by identifying monomials and reconstructing the stoichiometric structure.

\subsubsection{Algorithm}

Given an ODE system $\frac{dx_i}{dt} = f_i(x)$, the algorithm uses helper functions \texttt{allT} (extract all terms) and \texttt{isN} (detect negative sign):

\begin{enumerate}
\item \textbf{Extract all terms:} Use \texttt{allT[RHS[[i]]]} to expand each equation and extract all terms (monomials with coefficients)
\item \textbf{Separate by sign:} Use \texttt{isN[term]} to classify terms:
  \begin{itemize}
  \item Sources: positive terms (where \texttt{isN[term]=False})
  \item Sinks: negative terms (where \texttt{isN[term]=True})
  \end{itemize}
\item \textbf{Build rates (rts):} Join sources and negated sinks, remove duplicates: \texttt{rts = DeleteDuplicates[Join[sources, -sinks]]}
\item \textbf{Build gam ($\gamma$):} For each equation and each rate, check if rate appears:
  \begin{itemize}
  \item If rate appears as negative term: $\gamma_{ij} = -1$
  \item If rate appears as positive term: $\gamma_{ij} = +1$
  \item If rate does not appear: $\gamma_{ij} = 0$
  \end{itemize}
\item \textbf{Build alp ($\alpha$):} Reactant matrix from exponents: $\alpha_{ij} = \text{Exponent}[\text{rts}[[j]], \text{var}[[i]]]$
\item \textbf{Build bet ($\beta$):} Product matrix: $\beta = \gamma + \alpha$
\item \textbf{Build RN:} Construct reaction network from $\alpha$ (left side) and $\beta$ (right side)
\end{enumerate}

\textbf{Helper functions:}
\begin{itemize}
\item \texttt{allT[expr]}: Expands polynomial and returns list of all terms
\item \texttt{isN[term]}: Returns True if term has negative sign (coefficient -1 or negative number)
\end{itemize}

\subsubsection{Mathematical Foundation}

For an ODE system:
$$\frac{dx}{dt} = \sum_j \gamma_j \cdot r_j(x)$$

where $\gamma_j$ is the $j$-th column of the stoichiometric matrix and $r_j$ is the $j$-th reaction rate.

\textbf{Sign convention:}
\begin{itemize}
\item Positive-only terms $\rightarrow$ production (0 $\rightarrow$ species)
\item Negative-containing terms $\rightarrow$ consumption (reactants)
\item Constants (sources) $\rightarrow$ reactions from empty set
\end{itemize}

\subsubsection{Key Assumption}

\textbf{Positive-only monomials:} Monomials appearing only with positive sign are assumed to appear in exactly one reaction. This simplifies rate identification.

\subsubsection{Usage}

\begin{lstlisting}
(* Input: ODE system as list of expressions *)
RHS = {La - mu*s - be*s*i, be*s*i - (mu+ga)*i};
var = {s, i};

(* Convert to reaction network *)
{RN, rts, spe, alp, bet, gam} = ODE2RN[RHS, var];

(* Output: *)
(* RN: reaction network in standard format *)
(* rts: rate vector *)
(* spe: species list *)
(* alp: alpha matrix (reactants) *)
(* bet: beta matrix (products) *)
(* gam: gamma matrix (net) *)
\end{lstlisting}

\subsubsection{Example}

\textbf{Input ODE:}
\begin{align}
\frac{ds}{dt} &= \Lambda - \mu s - \beta s i\\
\frac{di}{dt} &= \beta s i - (\mu + \gamma) i
\end{align}

\textbf{Algorithm steps:}
\begin{enumerate}
\item \textbf{Extract terms:} allT gives $\{\Lambda, -\mu s, -\beta si\}$ for eq1, $\{\beta si, -\gamma i, -\mu i\}$ for eq2
\item \textbf{Separate by sign:} sources = $\{\Lambda, \beta si\}$, sinks = $\{-\mu s, -\beta si, -\gamma i, -\mu i\}$
\item \textbf{Rates:} rts = $\{\Lambda, \beta si, \mu s, \gamma i, \mu i\}$ (after removing duplicates)
\item \textbf{Gamma:}
$$\gamma = \begin{pmatrix} 1 & -1 & -1 & 0 & 0 \\ 0 & 1 & 0 & -1 & -1 \end{pmatrix}$$
\item \textbf{Alpha (exponents):}
$$\alpha = \begin{pmatrix} 0 & 1 & 1 & 0 & 0 \\ 0 & 1 & 0 & 1 & 1 \end{pmatrix}$$
\item \textbf{Beta = gamma + alpha:}
$$\beta = \begin{pmatrix} 1 & 0 & 0 & 0 & 0 \\ 0 & 2 & 0 & 0 & 0 \end{pmatrix}$$
\end{enumerate}

\textbf{Output RN:}
\begin{lstlisting}
RN = {0 -> s, i+s -> 2*i, s -> 0, i -> 0, i -> 0};
rts = {La, be*i*s, mu*s, ga*i, i*mu};
\end{lstlisting}

\subsubsection{Implementation Notes}

\begin{enumerate}
\item Function returns lists (not associations) following EpidCRN convention
\item Species names preserve case as strings in RN output (using SymbolName)
\item Rate vector corresponds to reaction order in RN
\item Stoichiometric matrices follow standard CRNT conventions
\item Verification: $\frac{dx}{dt} = \gamma \cdot rts$ reproduces original ODE
\item Matrix names: alp, bet, gam (3 letters for matrices)
\item Helper functions allT and isN use Expand and detect negative coefficients via pattern matching
\item Gamma matrix uses -1 for consumption (negative terms) and +1 for production (positive terms)
\item Alpha matrix extracts exponents directly using Exponent function
\end{enumerate}

\subsubsection{Location}

Implemented in \texttt{Core.wl} (lines 308-459) with helper functions:
\begin{itemize}
\item allT (line 312): Extract all terms from expanded polynomial
\item isN (line 318): Detect negative sign in term
\item ODE2RN (line 344): Main conversion function
\end{itemize}

Inverse operation to \texttt{extMat}.

\subsection{Subscript Converter: \texttt{subsCon}}

The \texttt{subsCon} function converts variable names to subscripted form for improved readability in graphs and visualizations.

\textbf{Purpose:} Transforms variable names like ``i12'', ``i1'', ``x23'' to subscripted forms where trailing digits become subscripts: $i_{12}$, $i_1$, $x_{23}$.

\textbf{Input:}
\begin{itemize}
\item \texttt{str}: String or Symbol to convert
\end{itemize}

\textbf{Output:}
\begin{itemize}
\item Subscripted expression if trailing digits found
\item Original expression otherwise
\end{itemize}

\textbf{Examples:}
\begin{verbatim}
subsCon["i12"]  (* Returns Subscript[i, 12] *)
subsCon["i1"]   (* Returns Subscript[i, 1] *)
subsCon["s"]    (* Returns s *)
subsCon[i12]    (* Returns Subscript[i, 12] *)
\end{verbatim}

\textbf{Usage:} This function is automatically used by \texttt{invGr} to create readable labels in invasion graphs. It can also be used independently for formatting variable names in plots and outputs.

\input{plan}

%\input{LCP}
%\input{FIST}
\end{document}

