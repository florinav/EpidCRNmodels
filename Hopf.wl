(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["Hopf`"]*)
(**)
(*fpHopf::usage="pos=fpHopf[RHS, var, conPar] yields all positive solutions for conPar, and examines*)
(*the eigenvalues of the first for possible closeness to Hopf";*)
(*pertIC::usage="pertIC[equilibrium, var, factor, n] creates perturbed initial conditions from an equilibrium."*)
(*TS::usage="TS[RHS, var, coP, tmax:100] computes time series and its limit from  initial conditions *)
(*1/var//Length."*)
(*intEqV::usage="equilibria = intEqV[RHS, var, coP] finds interior equilibrium points with verbose output and symbolic equilibria checking."*)
(*pertIC;findH;*)
(*intEq::usage="equilibria = intEq[RHS, var, coP, att] finds interior equilibrium points using FindRoot."*)
(*hopfD::usage="hopfPoints = hopfD[curve] detects Hopf bifurcation points from continuation curve data."*)
(**)
(**)
(*cont::usage="curve = cont2[RHS, var, att, par, coP, range, inp] performs continuation in user specified range."*)
(**)
(*hopfD::usage="hopfPoints = hopfD[curve] detects Hopf bifurcation points from continuation curve data."*)
(*phase::usage="phasePlot = phase[RHS, var, coP, tmax] creates phase portrait with multiple trajectories around equilibrium."*)
(*wF::usage="wF[bifParam, coP, RHS, var] performs workflow analysis at bifurcation parameter."*)
(*scanPar::usage="regions = scanPar[RHS, var, coP, par, ranges, att] scans parameter space to classify stability regions."*)
(*pltRegions::usage="pltRegions[scanResults, paramNames] plots parameter space regions from scanPar results."*)
(*ploR::usage="ploR[coP, R0A, E0, E1, E2, R12, R21] plots analytical boundaries from reproduction numbers."*)
(**)
(*Begin["`Private`"]*)
(**)
(*(*Optimization-based Hopf bifurcation finder*)findH[RHS_,var_,par_,coP_,optInd_,method_:"NelderMead",maxIter_:20,accGoal_:10^(-2),precGoal_:10^(-2),stopTol_:0.01,timeLimit_:60]:=Module[{optPar,objFunc},Print["Starting Hopf finder - TESTING PHASE 1"];*)
(*(*Extract parameters to optimize*)optPar=par[[optInd]];*)
(*Print["Parameters to optimize: ",optPar];*)
(*(*Define objective function*)objFunc[paramValues_]:=Module[{newCoP,replacementRules,posSols,complexEigs,eigs,result},(*Print current parameter values being tested*)Print["Testing parameter values: ",paramValues];*)
(*(*Create replacement rules properly*)replacementRules=Thread[optPar->paramValues];*)
(*Print["Replacement rules: ",replacementRules];*)
(*(*Create new parameter set by applying the replacement rules*)newCoP=coP/. replacementRules;*)
(*Print["Updated coP: ",newCoP];*)
(*(*Call fpHopf*){posSols,complexEigs,eigs}=fpHopf[RHS,var,newCoP];*)
(*(*Prepare return values*)result={posSols,If[Length[complexEigs]>0,Max[Re[complexEigs]],-Infinity]};*)
(*(*Print results*)Print["fpHopf returned: "];*)
(*Print["  posSols length: ",Length[posSols]];*)
(*Print["  Max[Re[complexEigs]]: ",result[[2]]];*)
(*result];*)
(*(*Test the objective function with initial parameter values*)Print["Testing objective function with initial values..."];*)
(*initialValues=optPar/. coP;*)
(*Print["Initial parameter values: ",initialValues];*)
(*objFunc[initialValues];*)
(*Print["Phase 1 testing complete - script ends here"];*)
(*(*EVERYTHING BELOW IS COMMENTED OUT FOR PHASE 1 TESTING*)*)
(*(*(*Verify starting point is stable*){posSols,complexEigs,eigs}=fpHopf[RHS,var,coP];*)
(*If[Length[eigs]>0,Print["Starting Max[Re[eigenvalues]] = ",Max[Re[eigs]]];*)
(*If[Max[Re[eigs]]>0,Print["WARNING: Starting point is already unstable!"];];];*)
(*(*Set up constraints:stop just before positive values*)constraints={objFunc[optPar]<=stopTol};*)
(*(*Add bounds:parameters should stay positive and reasonable*)Do[AppendTo[constraints,optPar[[i]]>0.001];*)
(*AppendTo[constraints,optPar[[i]]<10*startValues[[i]]];,{i,Length[optPar]}];*)
(*Print["Running optimization to find Hopf bifurcation (time limit: ",timeLimit," seconds)..."];*)
(*startTime=AbsoluteTime[];*)
(*(*OPTIMIZATION CALL*)result=TimeConstrained[NMaximize[{objFunc[optPar],constraints},Thread[{optPar,startValues}],Method->method,MaxIterations->maxIter,AccuracyGoal->accGoal,PrecisionGoal->precGoal],timeLimit,Print["Time limit reached! Returning best result so far..."];*)
(*{-1000,{}}];*)
(*(*Extract results*)If[result=!={-1000,{}},bestValue=result[[1]];*)
(*bestParams=optPar/. result[[2]];,Print["Optimization failed or timed out"];*)
(*bestValue=-1000;*)
(*bestParams=startValues;];*)
(*Print["Elapsed time: ",Round[AbsoluteTime[]-startTime,0.1]," seconds"];*)
(*Print["Optimization completed!"];*)
(*Print["Best Max[Re[eigenvalues]] = ",bestValue];*)
(*Print["Optimal parameter values: ",bestParams];*)
(*(*Create final parameter set*)finalCoP=coP;*)
(*Do[finalCoP=Join[DeleteCases[finalCoP,Rule[optPar[[i]],_]],{optPar[[i]]->bestParams[[i]]}];,{i,Length[optPar]}];*)
(*(*Verification*)Print["Verifying result..."];*)
(*{posSols,complexEigs,eigs}=fpHopf[RHS,var,finalCoP];*)
(*If[Length[eigs]>0,Print["Final Max[Re[eigenvalues]] = ",Max[Re[eigs]]];*)
(*If[Length[complexEigs]>0,Print["Complex eigenvalues found: ",Length[complexEigs]];*)
(*If[Abs[Max[Re[complexEigs]]]<0.01,Print["*** HOPF BIFURCATION DETECTED ***"];,Print["Complex eigenvalues but not at Hopf point"];];,Print["Only real eigenvalues found"];];,Print["ERROR: No eigenvalues computed in verification"];];*)
(*(*Return results as list:{maxRe,optParams,finalCoP,eigenvals,complexEigs,isHopf}*){bestValue,Thread[optPar->bestParams],finalCoP,eigs,complexEigs,(Length[complexEigs]>0&&Abs[Max[Re[complexEigs]]]<0.01)}*)];*)
(**)
(*(*USAGE EXAMPLES:*)*)
(**)
(*(*Light/fast call for testing (finishes quickly):*)*)
(*(*hopfResult=findH[RHS,var,par,coP,{4}];*)*)
(**)
(*(*Even lighter call with very loose settings:*)*)
(*(*hopfResult=findH[RHS,var,par,coP,{4},"NelderMead",10,0.1,0.1,0.05,30];*)*)
(**)
(*(*Optimize multiple parameters:*)*)
(*(*hopfResult=findH[RHS,var,par,coP,{3,4}];*)*)
(**)
(*(*Access results from list:*)*)
(*(*{maxRe,optParams,finalCoP,eigenvals,complexEigs,isHopf}=hopfResult;*)*)
(**)
(*(*===PERTURBED INITIAL CONDITIONS===*)*)
(*pertIC[equilibrium_,var_,factor_:0.1,minq_:0.001,n_:1]:=Module[{eqVals,pertVals},eqVals=var/. equilibrium;*)
(*Table[pertVals=Max[#,minq]&/@(eqVals+factor*RandomReal[{-1,1},Length[var]]*Abs[eqVals]);*)
(*pertVals=pertVals(Total[eqVals]/Total[pertVals]);*)
(*Thread[var->pertVals],{n}]];*)
(**)
(*TS[RHS_,var_,coP_,tmax_:100]:=Module[{varT,u0,initialConditions,rhsT,odeSystem,sol,solFun,timeWindow,sampleTimes,sampleVals,variances,finalVals,eps=10^-6,t},(*Time-dependent variables*)varT=Through[var[t]];*)
(*(*Initial conditions*)initialConditions=Thread[(varT/. t->0)==(var/. coP)];*)
(*(*RHS with substituted parameters and time variables*)rhsT=RHS/. Thread[var->varT];*)
(*(*Full ODE system*)odeSystem=Join[Thread[D[varT,t]==rhsT],initialConditions];*)
(*(*Solve ODE system*)sol=Quiet@NDSolve[odeSystem,varT,{t,0,tmax},Method->{"BDF"}];*)
(*If[!MatchQ[sol,{(_Rule|_List)...}],Print["NDSolve failed"];*)
(*Return[$Failed];];*)
(*(*Extract solution functions*)solFun=#[[0]]&/@(varT/. sol[[1]]);*)
(*(*(*Oscillation check:sample last 20 units of time*)timeWindow={Max[0,tmax-20],tmax};*)
(*sampleTimes=Range[timeWindow[[1]],timeWindow[[2]],0.2];*)
(*sampleVals=Table[Through[var[t]]/. sol[[1]]/. t->\[Tau],{\[Tau],sampleTimes}];*)
(*variances=Variance/@Transpose[sampleVals];*)
(*If[Max[variances]>eps,Print["\:26a0\:fe0f  WARNING: Oscillations detected."],(*Otherwise return final value*)finalVals=(Through[var[t]]/. sol[[1]]/. t->tmax);*)
(*(*Print["\:2705 Stable convergence. Limit = ",finalVals];*);*)
(*Return[finalVals];];*)(*Return full solution functions*)(*Print[solFun];*)solFun];*)
(**)
(*(*Parameter scanning function for Hopf bifurcation detection*)*)
(*scanPar[RHS_,var_,par_,coP_,plotInd_,plot_,wRan_:0.5,hRan_:0.5,gridRes_:8,hTol_:0.01]:=Module[{plotVar,beta1Symbol,beta2Symbol,beta1Center,beta2Center,beta1Range,beta2Range,gridPoints,hopfPoints,hopfRealParts,testCoP,posSols,complexEigs,eigs,overlayPlot,beta1Min,beta1Max,beta2Min,beta2Max,totalTests,hopfCount},Print["Scanning ",gridRes^2," points (wRan=",wRan,", hRan=",hRan,", hTol=",hTol,"] for Hopf bifurcations..."];*)
(*(*Extract the two parameters to vary*)plotVar=par[[plotInd]];*)
(*beta1Symbol=plotVar[[1]];*)
(*beta2Symbol=plotVar[[2]];*)
(*(*Get center values from coP*)beta1Center=beta1Symbol/. coP;*)
(*beta2Center=beta2Symbol/. coP;*)
(*(*Define ranges around center values*)beta1Min=beta1Center*(1-wRan);*)
(*beta1Max=beta1Center*(1+wRan);*)
(*beta2Min=beta2Center*(1-hRan);*)
(*beta2Max=beta2Center*(1+hRan);*)
(*(*Ensure positive values*)beta1Min=Max[beta1Min,0.001];*)
(*beta2Min=Max[beta2Min,0.001];*)
(*(*Create uniform grid*)beta1Range=Table[beta1Min+(beta1Max-beta1Min)*k/(gridRes-1),{k,0,gridRes-1}];*)
(*beta2Range=Table[beta2Min+(beta2Max-beta2Min)*k/(gridRes-1),{k,0,gridRes-1}];*)
(*gridPoints=Flatten[Table[{b1,b2},{b1,beta1Range},{b2,beta2Range}],1];*)
(*totalTests=Length[gridPoints];*)
(*hopfPoints={};*)
(*hopfRealParts={};*)
(*hopfCount=0;*)
(*(*Test each grid point for Hopf bifurcations*)Do[(*Create parameter set for this grid point*)testCoP=Join[DeleteCases[coP,Rule[beta1Symbol,_]|Rule[beta2Symbol,_]],{beta1Symbol->gridPoints[[j,1]],beta2Symbol->gridPoints[[j,2]]}];*)
(*(*Test for equilibrium and eigenvalues*){posSols,complexEigs,eigs}=Quiet[fpHopf[RHS,var,testCoP]];*)
(*(*Check if fpHopf succeeded*)If[Length[posSols]>0,(*Check for Hopf bifurcation:complex eigenvalues with real part~=0*)If[Length[complexEigs]>0&&Abs[Max[Re[complexEigs]]]<hTol,hopfCount++;*)
(*AppendTo[hopfPoints,{gridPoints[[j,1]],gridPoints[[j,2]]}];*)
(*AppendTo[hopfRealParts,Max[Re[complexEigs]]];];];,{j,1,totalTests}];*)
(*If[Length[hopfPoints]>0,Print["Found ",Length[hopfPoints]," Hopf points with real parts: ",hopfRealParts];,Print["Found ",Length[hopfPoints]," Hopf points"];];*)
(*(*Always create overlay plot with search rectangle*)overlayPlot=Show[plot,Graphics[{(*Search range rectangle*)EdgeForm[{Thick,Gray,Dashed}],FaceForm[None],Rectangle[{beta1Min,beta2Min},{beta1Max,beta2Max}],(*Center point*)Blue,PointSize[0.012],Point[{{beta1Center,beta2Center}}],(*Hopf points if any found*)If[Length[hopfPoints]>0,{Red,PointSize[0.012],Point[hopfPoints]},{}],(*Labels*)Text[Style["Search Range"<>If[Length[hopfPoints]>0," ("<>ToString[Length[hopfPoints]]<>" Hopf)"," (No Hopf)"],FontSize->8,FontWeight->Bold,FontColor->Gray],{beta1Min+0.02*(beta1Max-beta1Min),beta2Max-0.02*(beta2Max-beta2Min)}]}],PlotLabel->"Parameter Scan: "<>ToString[Length[hopfPoints]]<>" Hopf Points Found",PlotRange->{{beta1Min*0.9,beta1Max*1.1},{beta2Min*0.9,beta2Max*1.1}}];*)
(*overlayPlot];*)
(**)
(*(*USAGE EXAMPLES:*)*)
(*(*Basic usage with default settings:*)*)
(*(*myPlot=scanPar[RHS,var,par,coP,{3,4},analyticalPlot];*)*)
(**)
(*(*With custom range and resolution:*)*)
(*(*myPlot=scanPar[RHS,var,par,coP,{3,4},analyticalPlot,0.3,0.6,12,0.005];*)*)
(*(*-wRan:0.3 (+/-30% width around center)*)*)
(*(*-hRan:0.6 (+/-60% height around center)*)*)
(*(*-gridRes:12 (12x12=144 test points)*)*)
(*(*-hTol:0.005 (stricter Hopf tolerance,default is 0.01)*)*)
(**)
(*(*Access the plot:*)*)
(*(*myPlot  (*Shows the plot directly*)*)*)
(**)
(*intEq[RHS_,var_,coP_,att_]:=Module[{eqs,sols,cleanSols,positiveSols,threshold=10^(-10),perturbedICs,attRules},eqs=Thread[RHS==0]/. coP;*)
(*(*Convert att list to replacement rules*)attRules=Thread[var->att];*)
(*(*Use attRules as seed instead of calling TS*)perturbedICs=Join[{var/. attRules},var/. #&/@pertIC[attRules,var,0.1,15],var/. #&/@pertIC[attRules,var,0.3,8]];*)
(*sols=Table[Quiet[FindRoot[eqs,Evaluate[Thread[{var,perturbedICs[[i]]}]],Method->"Newton"]],{i,1,Length[perturbedICs]}];*)
(*sols=Select[sols,Head[#]===List&&Length[#]==Length[var]&];*)
(*cleanSols=sols/. {x_?NumericQ:>If[Abs[x]<threshold,0,x]};*)
(*cleanSols=DeleteDuplicatesBy[cleanSols,Round[Sort[var/. #],10^(-6)]&];*)
(*positiveSols=Select[cleanSols,And@@(#>threshold&/@(var/. #))&];*)
(*Print["Found ",Length[positiveSols]," equilibria"];*)
(*positiveSols];*)
(**)
(**)
(**)
(**)
(**)
(*(*fpHopf function for finding equilibria and stability analysis*)*)
(*fpHopf[RHS_,var_,conPar_]:=Module[{eqns,allSols,posSols,eq,jac,eigs,complexEigs,realParts},(*Create equations properly*)eqns=Thread[(RHS/. conPar)==0];*)
(*(*Find all real solutions*)allSols=Quiet[NSolveValues[eqns,var,Reals]];*)
(*allSols=Union[allSols,SameTest->(Norm[#1-#2]<10^-10&)];*)
(*allSols=Select[allSols,AllTrue[#,#>=0&]&];*)
(*(*Remove duplicates*)(*Filter for positive solutions (coexistence equilibria)*)posSols=Select[allSols,AllTrue[#,#>0&]&];*)
(*(*Print[Length[allSols]," real solutions ",Length[posSols]," positive solutions found *)
(*with conPar=",conPar];*)If[Length[posSols]==0,(*Print["No coexistence equilibrium found"];*)Return[{{},{},{}}];];*)
(*(*Use first positive solution*)eq=posSols[[1]];*)
(*(*Print["Using equilibrium: ",eq];*)(*Compute Jacobian and eigenvalues*)jac=D[RHS,{var}]/. conPar/. Thread[var->eq];*)
(*eigs=Chop[Eigenvalues[jac]//N];*)
(*complexEigs=Select[eigs,Im[#]!=0&];*)
(*realParts=Re[complexEigs];*)
(*(*Print["Eigenvalues: ",eigs];*)(*NonVerbose version-only prints for Hopf bifurcations and unstable oscillations*)If[Length[complexEigs]>=2,If[Max[Abs[realParts]]<0.1&&Max[Abs[Im[complexEigs]]]>0.01,Print[Length[complexEigs]," complex eigs. Result: Hopf"];*)
(*"Hopf",If[Max[realParts]>0.01,Print[Length[complexEigs]," complex eigs with positive real part. Result: Unstable oscillation"];*)
(*"Unstable","Complex"]],"Real"];*)
(*{posSols,complexEigs,eigs}];*)
(**)
(*(*Enhanced Continuation function with explicit parameter handling*)*)
(*cont[RHS_,var_,par_,coP_,stepSize_,plotInd_:{3,4},bifInd_:4,analyticalPlot_:None]:=Module[{posSols,bifParam,currentVal,curve,newCoP,paramVal,complexEigs,eigs,eq,maxRealPart,complexPairs,bifPlot,plotC,forwardCurve,backwardCurve,i,maxIter=10,successCount=0,hopfPoints,testedPoints={},startingPoint,adaptiveStep,currentStep,overlayPossible,beta1Symbol,beta2Symbol,beta1Val,beta2Val,startPosInCurve},(*Debug input parameters*)(*Print["DEBUG: par length = ",Length[par]];*)
(*Print["DEBUG: bifInd = ",bifInd," (should be single number like 4)"];*)
(*Print["DEBUG: plotInd = ",plotInd," (should be like {3,4})"];*)(*Use explicit parameter symbols*)bifParam=par[[bifInd]];*)
(*beta1Symbol=par[[plotInd[[1]]]];*)
(*beta2Symbol=par[[plotInd[[2]]]];*)
(*currentVal=bifParam/. coP;*)
(*Print["Starting bifParam = ",bifParam," (index ",bifInd,"] at ",currentVal];*)
(*Print["Plot parameters: \[Beta]\:2081 = ",beta1Symbol," (index ",plotInd[[1]],"], \[Beta]\:2082 = ",beta2Symbol," (index ",plotInd[[2]],"]"];*)
(*(*Check overlay compatibility*)overlayPossible=analyticalPlot=!=None&&MemberQ[plotInd,bifInd];*)
(*If[overlayPossible,Print["\:2705 Will overlay on analytical plot (bifParam \[Element] plotInd)"];,If[analyticalPlot=!=None,Print["\:26a0\:fe0f Standalone plot only (bifParam \[NotElement] plotInd)"];];];*)
(*(*Get starting equilibrium*){posSols,complexEigs,eigs}=fpHopf[RHS,var,coP];*)
(*If[Length[posSols]==0,Print["ERROR: No equilibrium found at starting coP!"];*)
(*Return[{}];];*)
(*(*Include starting equilibrium with \[Beta] coordinates*){beta1Val,beta2Val}={beta1Symbol,beta2Symbol}/. coP;*)
(*startingPoint=<|"Parameter"->currentVal,"Values"->posSols[[1]],"MaxRealPart"->If[Length[eigs]>0,Max[Re[eigs]],0],"ComplexPairs"->Length[complexEigs]/2,"Eigenvalues"->eigs,"ComplexEigs"->complexEigs,"Beta1"->beta1Val,"Beta2"->beta2Val|>;*)
(*curve={};*)
(*forwardCurve={startingPoint};*)
(*backwardCurve={};*)
(*(*Adaptive step size function*)adaptiveStep[stepNum_,baseStep_]:=Which[stepNum<=2,baseStep/5,stepNum<=4,baseStep/3,stepNum<=6,baseStep/2,True,baseStep];*)
(*(*Forward continuation*)i=1;*)
(*While[True,currentStep=adaptiveStep[i,stepSize];*)
(*paramVal=currentVal+i*currentStep;*)
(*AppendTo[testedPoints,{"Forward",paramVal}];*)
(*newCoP=Join[DeleteCases[coP,Rule[bifParam,_]],{bifParam->paramVal}];*)
(*{beta1Val,beta2Val}={beta1Symbol,beta2Symbol}/. newCoP;*)
(*{posSols,complexEigs,eigs}=fpHopf[RHS,var,newCoP];*)
(*If[Length[posSols]>0,eq=posSols[[1]];*)
(*maxRealPart=If[Length[eigs]>0,Max[Re[eigs]],0];*)
(*complexPairs=Length[complexEigs]/2;*)
(*successCount++;*)
(*If[Length[complexEigs]>0&&Abs[Max[Re[complexEigs]]]<0.01,Print["*** HOPF BIFURCATION FOUND at parameter = ",paramVal," ***"];];*)
(*AppendTo[forwardCurve,<|"Parameter"->paramVal,"Values"->eq,"MaxRealPart"->maxRealPart,"ComplexPairs"->complexPairs,"Eigenvalues"->eigs,"ComplexEigs"->complexEigs,"Beta1"->beta1Val,"Beta2"->beta2Val|>];*)
(*i++;*)
(*If[i>=maxIter,Break[]];,Break[];];];*)
(*(*Backward continuation*)i=1;*)
(*While[True,currentStep=adaptiveStep[i,stepSize];*)
(*paramVal=currentVal-i*currentStep;*)
(*If[paramVal<=0,Break[]];*)
(*AppendTo[testedPoints,{"Backward",paramVal}];*)
(*newCoP=Join[DeleteCases[coP,Rule[bifParam,_]],{bifParam->paramVal}];*)
(*{beta1Val,beta2Val}={beta1Symbol,beta2Symbol}/. newCoP;*)
(*{posSols,complexEigs,eigs}=fpHopf[RHS,var,newCoP];*)
(*If[Length[posSols]>0,eq=posSols[[1]];*)
(*maxRealPart=If[Length[eigs]>0,Max[Re[eigs]],0];*)
(*complexPairs=Length[complexEigs]/2;*)
(*successCount++;*)
(*If[Length[complexEigs]>0&&Abs[Max[Re[complexEigs]]]<0.01,Print["*** HOPF BIFURCATION FOUND at parameter = ",paramVal," ***"];];*)
(*PrependTo[backwardCurve,<|"Parameter"->paramVal,"Values"->eq,"MaxRealPart"->maxRealPart,"ComplexPairs"->complexPairs,"Eigenvalues"->eigs,"ComplexEigs"->complexEigs,"Beta1"->beta1Val,"Beta2"->beta2Val|>];*)
(*i++;*)
(*If[i>maxIter,Break[]];,Break[];];];*)
(*(*Combine curves*)curve=Join[backwardCurve,forwardCurve];*)
(*Print["Found ",Length[curve]," points, tested ",Length[testedPoints]," parameters"];*)
(*If[Length[curve]>0,Print["Parameter range: ",curve[[1]]["Parameter"]," to ",curve[[-1]]["Parameter"]];];*)
(*(*Hopf analysis*)Print["\n=== HOPF BIFURCATION ANALYSIS ==="];*)
(*hopfPoints=Select[curve,Length[#["ComplexEigs"]]>0&&Abs[Max[Re[#["ComplexEigs"]]]]<0.01&];*)
(*If[Length[hopfPoints]>0,Print["HOPF BIFURCATIONS FOUND at parameters:"];*)
(*Do[Print["  Parameter = ",pt["Parameter"]],{pt,hopfPoints}];,Print["NO HOPF BIFURCATIONS FOUND in parameter range"];];*)
(*(*Plotting*)If[Length[curve]>1,(*S-shaped continuation curve*)curvePoints={#["Parameter"],#["Values"][[1]]}&/@curve;*)
(*startPosInCurve=Length[backwardCurve]+1;*)
(*startPoint=curvePoints[[startPosInCurve]];*)
(*bifPlot=ListLinePlot[curvePoints,PlotLegends->{"S: "<>ToString[var[[1]]]},AxesLabel->{ToString[bifParam],ToString[var[[1]]]},PlotLabel->"S-shaped Continuation Curve",ImageSize->600,Frame->True,PlotStyle->Blue,Epilog->{Pink,PointSize[0.008],Point[{#,0}&/@testedPoints[[All,2]]],Blue,PointSize[0.006],Point[curvePoints],Red,PointSize[0.012],Point[startPoint],Black,Arrowheads[0.015],Module[{leftArrow,rightArrow},leftArrow=If[startPosInCurve>1,Arrow[{startPoint,curvePoints[[startPosInCurve-1]]}],{}];*)
(*rightArrow=If[startPosInCurve<Length[curvePoints],Arrow[{startPoint,curvePoints[[startPosInCurve+1]]}],{}];*)
(*{leftArrow,rightArrow}],Text[Style["p\:2080",FontSize->10,FontWeight->Bold,FontColor->Red],startPoint+{0.02,0.05}]}];*)
(*Print[bifPlot];*)
(*(*Overlay plot*)If[overlayPossible,Print["\|01f3a8 Creating overlay on analytical plot..."];*)
(*overlayPoints={#["Beta1"],#["Beta2"]}&/@curve;*)
(*overlayStart=overlayPoints[[startPosInCurve]];*)
(*searchOverlayPoints=Table[Module[{testCoP},testCoP=Join[DeleteCases[coP,Rule[bifParam,_]],{bifParam->testedPoints[[i,2]]}];*)
(*{beta1Symbol,beta2Symbol}/. testCoP],{i,1,Length[testedPoints]}];*)
(*plotC=Show[analyticalPlot,Graphics[{Thick,Purple,Line[overlayPoints],Red,PointSize[0.015],Point[overlayStart],Orange,PointSize[0.010],Point[searchOverlayPoints],Purple,PointSize[0.008],Point[overlayPoints],Black,Arrowheads[0.02],Module[{leftArrow,rightArrow},leftArrow=If[startPosInCurve>1,Arrow[{overlayStart,overlayPoints[[startPosInCurve-1]]}],{}];*)
(*rightArrow=If[startPosInCurve<Length[overlayPoints],Arrow[{overlayStart,overlayPoints[[startPosInCurve+1]]}],{}];*)
(*{leftArrow,rightArrow}],Text[Style["p\:2080",FontSize->10,FontWeight->Bold,FontColor->Red],overlayStart+{0.02,0.02}],Text[Style["Hopf Search Path",FontSize->10,FontWeight->Bold,FontColor->Purple],{Mean[overlayPoints[[All,1]]],Max[overlayPoints[[All,2]]]+0.05}]}],PlotLabel->"Analytical Boundaries + Hopf Search Path"];*)
(*Print[plotC];];];*)
(*curve];*)
(**)
(*hopfD[curve_]:=Module[{hopfPoints,stabilityPlot,hopfPlot},If[Length[curve]<3,Print["hopfD needs \[GreaterEqual]3 points, got ",Length[curve]];*)
(*Return[{}]];*)
(*(*Check if curve has required fields*)If[!KeyExistsQ[curve[[1]],"MaxRealPart"],Print["Error: curve missing stability data. Run cont2 first."];*)
(*Return[{}]];*)
(*stabilityPlot=ListLinePlot[{#["Parameter"],#["MaxRealPart"]}&/@curve,AxesLabel->{"Parameter","Max Re(\[Lambda])"},PlotLabel->"Stability Analysis",PlotStyle->Blue,GridLines->{None,{0}},GridLinesStyle->Directive[Red,Dashed],ImageSize->400];*)
(*hopfPoints=Select[Table[Module[{prev,curr,next,prevReal,currReal,hasComplex},{prev,curr,next}={curve[[i-1]],curve[[i]],If[i<Length[curve],curve[[i+1]],curve[[i]]]};*)
(*{prevReal,currReal}={prev["MaxRealPart"],curr["MaxRealPart"]};*)
(*hasComplex=curr["ComplexPairs"]>0;*)
(*If[hasComplex&&prevReal*currReal<0,<|"parBif"->curr["Parameter"],"Type"->"Hopf"|>,Nothing]],{i,2,Length[curve]-1}],#=!=Nothing&];*)
(*If[Length[hopfPoints]>0,hopfPlot=ListPlot[{#["parBif"],0}&/@hopfPoints,PlotStyle->{Red,PointSize[0.015]}];*)
(*Print[Show[stabilityPlot,hopfPlot,PlotLabel->"Stability Analysis with Hopf Points"]];*)
(*Print["hopfD found ",Length[hopfPoints]," Hopf points at parameters: ",#["parBif"]&/@hopfPoints];,Print[stabilityPlot];*)
(*Print["hopfD found no Hopf points"];];*)
(*hopfPoints];*)
(**)
(*(*Usage example:curve=cont2[RHS,var,initialEq,{param},coP,0.01];*)
(*hopfPoints=hopfD[curve];*)*)
(*End[]*)
(*EndPackage[]*)



