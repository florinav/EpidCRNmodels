(* ::Package:: *)

(* ::Input:: *)
(*(*EpidCRN Bifurcation Subpackage-Bifurcation Analysis and Parameter Scanning*)BeginPackage["EpidCRN`Bifurcation`",{"EpidCRN`Core`","EpidCRN`Boundary`"}];*)
(**)
(*(* =========================================================================*)*)
(*(*BIFURCATION ANALYSIS-Hopf bifurcations and parameter scanning*)*)
(*(* =========================================================================*)*)
(**)
(*Begin["`Private`"];*)
(**)
(*(* =========================================================================*)*)
(*(*HOPF BIFURCATION ANALYSIS*)*)
(*(* =========================================================================*)*)
(**)
(*fpHopf[RHS_,var_,par_,p0val_]:=Module[{eqns,allSols,posSols,eq,jac,eigs,complexEigs,upperEig,angle,coP},(*Create substitution rules*)coP=Thread[par->p0val];*)
(*(*Create equations and find positive solutions*)eqns=Thread[(RHS/. coP)==0];*)
(*allSols=Quiet[NSolveValues[eqns,var,Reals]];*)
(*allSols=Union[allSols,SameTest->(Norm[#1-#2]<10^-10&)];*)
(*allSols=Select[allSols,AllTrue[#,#>=0&]&];*)
(*posSols=Select[allSols,AllTrue[#,#>0&]&];*)
(*If[Length[posSols]==0,Return[{{},{},-90,{}}];];*)
(*(*Use first positive solution for eigenvalue analysis*)eq=posSols[[1]];*)
(*jac=D[RHS,{var}]/. coP/. Thread[var->eq];*)
(*eigs=Chop[Eigenvalues[jac]//N];*)
(*complexEigs=Select[eigs,Im[#]!=0&];*)
(*(*Calculate angle*)angle=If[Length[complexEigs]>0,upperEig=First[Select[complexEigs,Im[#]>0&]];*)
(*ArcTan[Re[upperEig]/Im[upperEig]]*180/Pi,-90];*)
(*{posSols,complexEigs,angle,eigs}];*)
(**)
(*simpleOptHopf[RHS_,var_,par_,coP_,optInd_,numTries_:10]:=Module[{p0val,bestAngle,bestValues,i,testValues,newP0Val,posSols,complexEigs,eigs,currentAngle},Print["Starting simple optimization - angle-based objective"];*)
(*p0val=par/. coP;*)
(*newP0Val=p0val;*)
(*{posSols,complexEigs,eigs}=fpHopf[RHS,var,par,newP0Val];*)
(*bestAngle=If[Length[complexEigs]>0,Module[{upperEig},upperEig=First[Select[complexEigs,Im[#]>0&]];*)
(*ArcTan[Re[upperEig]/Im[upperEig]]*180/Pi],90];*)
(*bestValues=p0val[[optInd]];*)
(*Print["Initial angle = ",bestAngle," degrees"];*)
(*Do[testValues=bestValues*(1+0.5*RandomReal[{-1,1},Length[optInd]]);*)
(*testValues=Max[#,0.001]&/@testValues;*)
(*newP0Val=p0val;*)
(*newP0Val[[optInd]]=testValues;*)
(*{posSols,complexEigs,eigs}=fpHopf[RHS,var,par,newP0Val];*)
(*currentAngle=If[Length[complexEigs]>0,Module[{upperEig},upperEig=First[Select[complexEigs,Im[#]>0&]];*)
(*ArcTan[Re[upperEig]/Im[upperEig]]*180/Pi],90];*)
(*(*Maximize angle:move from negative towards positive*)If[currentAngle>bestAngle,bestAngle=currentAngle;*)
(*bestValues=testValues;*)
(*Print["Improvement: angle = ",currentAngle," degrees at ",testValues];*)
(*(*Stop if we reach positive (Hopf detected)*)If[currentAngle>0,Print["*** HOPF BIFURCATION DETECTED: angle = ",currentAngle," degrees ***"];*)
(*Break[];];];,{i,1,numTries}];*)
(*Print["Best angle = ",bestAngle," degrees"];*)
(*Print["Best values = ",bestValues];*)
(*Module[{finalP0Val},finalP0Val=p0val;*)
(*finalP0Val[[optInd]]=bestValues;*)
(*{bestAngle,bestValues,finalP0Val}]];*)
(**)
(*optHopf[RHS_,var_,par_,coP_,optInd_,timeLimit_:60,method_:"NelderMead",accGoal_:4,precGoal_:4,maxIter_:200]:=Module[{objFunc,p0val,varList,constraints,lowerBounds,upperBounds,result,startTime,initialAngle,elapsedTime},Print["Starting Mathematica optimization - angle-based objective"];*)
(*objFunc=objHopf[RHS,var,par,coP,optInd];*)
(*p0val=par/. coP;*)
(*initialAngle=objFunc[p0val[[optInd]]];*)
(*Print["Initial angle = ",initialAngle," degrees"];*)
(*varList=par[[optInd]];*)
(*lowerBounds=0.5*p0val[[optInd]];*)
(*upperBounds=1.5*p0val[[optInd]];*)
(*constraints=Table[lowerBounds[[i]]<=varList[[i]]<=upperBounds[[i]],{i,Length[optInd]}];*)
(*startTime=AbsoluteTime[];*)
(*(*FIX:Extract individual variables for NMaximize*)Module[{var1,var2},{var1,var2}=varList;*)
(*result=TimeConstrained[NMaximize[(*Maximize angle:from negative towards positive*){objFunc[{var1,var2}],And@@constraints},{var1,var2},Method->method,MaxIterations->maxIter,AccuracyGoal->accGoal,PrecisionGoal->precGoal],timeLimit,$Failed];];*)
(*elapsedTime=Round[AbsoluteTime[]-startTime,0.1];*)
(*Print["Elapsed time: ",elapsedTime," seconds"];*)
(*If[result=!=$Failed&&Length[result]>=2,Module[{maxAngle,optParams,bestValues,finalP0Val,bestAngle},{maxAngle,optParams}=result;*)
(*bestValues=Values[optParams];*)
(*bestAngle=objFunc[bestValues];(*Get the actual angle*)If[bestAngle>0,Print["*** HOPF BIFURCATION DETECTED: angle = ",bestAngle," degrees ***"];,Print["Best angle = ",bestAngle," degrees"];];*)
(*Print["Best values = ",bestValues];*)
(*finalP0Val=p0val;*)
(*finalP0Val[[optInd]]=bestValues;*)
(*{bestAngle,bestValues,finalP0Val}],Print["Optimization failed - returning initial values"];*)
(*Print["Best angle = ",initialAngle," degrees"];*)
(*Print["Best values = ",p0val[[optInd]]];*)
(*{initialAngle,p0val[[optInd]],p0val}]];*)
(**)
(*(* =========================================================================*)*)
(*(*CONTINUATION ANALYSIS*)*)
(*(* =========================================================================*)*)
(**)
(*cont[RHS_,var_,par_,p0val_,stepSize_,plotInd_:{3,4},bifInd_:4,analyticalPlot_:None]:=Module[{posSols,bifParamIndex,currentVal,curve,newP0Val,paramVal,complexEigs,eigs,eq,maxRealPart,complexPairs,bifPlot,plotC,forwardCurve,backwardCurve,i,maxIter=10,successCount=0,hopfPoints,testedPoints={},startingPoint,adaptiveStep,currentStep,overlayPossible,beta1Index,beta2Index,beta1Val,beta2Val,startPosInCurve},(*Use parameter indices*)bifParamIndex=bifInd;*)
(*beta1Index=plotInd[[1]];*)
(*beta2Index=plotInd[[2]];*)
(*currentVal=p0val[[bifParamIndex]];*)
(*Print["Starting bifParam index ",bifParamIndex," at value ",currentVal];*)
(*Print["Plot parameters at indices: ",plotInd," with values: ",p0val[[plotInd]]];*)
(*(*Check overlay compatibility*)overlayPossible=analyticalPlot=!=None&&MemberQ[plotInd,bifParamIndex];*)
(*If[overlayPossible,Print["Will overlay on analytical plot (bifParam in plotInd)"];,If[analyticalPlot=!=None,Print["Standalone plot only (bifParam not in plotInd)"];];];*)
(*(*Get starting equilibrium*){posSols,complexEigs,eigs}=fpHopf[RHS,var,par,p0val];*)
(*If[Length[posSols]==0,Print["ERROR: No equilibrium found at starting p0val!"];*)
(*Return[{}];];*)
(*(*Include starting equilibrium with beta coordinates*){beta1Val,beta2Val}=p0val[[plotInd]];*)
(*startingPoint=<|"Parameter"->currentVal,"Values"->posSols[[1]],"MaxRealPart"->If[Length[eigs]>0,Max[Re[eigs]],0],"ComplexPairs"->Length[complexEigs]/2,"Eigenvalues"->eigs,"ComplexEigs"->complexEigs,"Beta1"->beta1Val,"Beta2"->beta2Val|>;*)
(*curve={};*)
(*forwardCurve={startingPoint};*)
(*backwardCurve={};*)
(*(*Adaptive step size function*)adaptiveStep[stepNum_,baseStep_]:=Which[stepNum<=2,baseStep/5,stepNum<=4,baseStep/3,stepNum<=6,baseStep/2,True,baseStep];*)
(*(*Forward continuation*)i=1;*)
(*While[True,currentStep=adaptiveStep[i,stepSize];*)
(*paramVal=currentVal+i*currentStep;*)
(*AppendTo[testedPoints,{"Forward",paramVal}];*)
(*newP0Val=p0val;*)
(*newP0Val[[bifParamIndex]]=paramVal;*)
(*{beta1Val,beta2Val}=newP0Val[[plotInd]];*)
(*{posSols,complexEigs,eigs}=fpHopf[RHS,var,par,newP0Val];*)
(*If[Length[posSols]>0,eq=posSols[[1]];*)
(*maxRealPart=If[Length[eigs]>0,Max[Re[eigs]],0];*)
(*complexPairs=Length[complexEigs]/2;*)
(*successCount++;*)
(*If[Length[complexEigs]>0&&Abs[Max[Re[complexEigs]]]<0.01,Print["*** HOPF BIFURCATION FOUND at parameter = ",paramVal," ***"];];*)
(*AppendTo[forwardCurve,<|"Parameter"->paramVal,"Values"->eq,"MaxRealPart"->maxRealPart,"ComplexPairs"->complexPairs,"Eigenvalues"->eigs,"ComplexEigs"->complexEigs,"Beta1"->beta1Val,"Beta2"->beta2Val|>];*)
(*i++;*)
(*If[i>=maxIter,Break[]];,Break[];];];*)
(*(*Backward continuation*)i=1;*)
(*While[True,currentStep=adaptiveStep[i,stepSize];*)
(*paramVal=currentVal-i*currentStep;*)
(*If[paramVal<=0,Break[]];*)
(*AppendTo[testedPoints,{"Backward",paramVal}];*)
(*newP0Val=p0val;*)
(*newP0Val[[bifParamIndex]]=paramVal;*)
(*{beta1Val,beta2Val}=newP0Val[[plotInd]];*)
(*{posSols,complexEigs,eigs}=fpHopf[RHS,var,par,newP0Val];*)
(*If[Length[posSols]>0,eq=posSols[[1]];*)
(*maxRealPart=If[Length[eigs]>0,Max[Re[eigs]],0];*)
(*complexPairs=Length[complexEigs]/2;*)
(*successCount++;*)
(*If[Length[complexEigs]>0&&Abs[Max[Re[complexEigs]]]<0.01,Print["*** HOPF BIFURCATION FOUND at parameter = ",paramVal," ***"];];*)
(*PrependTo[backwardCurve,<|"Parameter"->paramVal,"Values"->eq,"MaxRealPart"->maxRealPart,"ComplexPairs"->complexPairs,"Eigenvalues"->eigs,"ComplexEigs"->complexEigs,"Beta1"->beta1Val,"Beta2"->beta2Val|>];*)
(*i++;*)
(*If[i>maxIter,Break[]];,Break[];];];*)
(*(*Combine curves*)curve=Join[backwardCurve,forwardCurve];*)
(*Print["Found ",Length[curve]," points, tested ",Length[testedPoints]," parameters"];*)
(*If[Length[curve]>0,Print["Parameter range: ",curve[[1]]["Parameter"]," to ",curve[[-1]]["Parameter"]];];*)
(*curve];*)
(**)
(*hopfD[curve_]:=Module[{hopfPoints,stabilityPlot,hopfPlot},If[Length[curve]<3,Print["hopfD needs >=3 points, got ",Length[curve]];*)
(*Return[{}]];*)
(*(*Check if curve has required fields*)If[!KeyExistsQ[curve[[1]],"MaxRealPart"],Print["Error: curve missing stability data. Run cont first."];*)
(*Return[{}]];*)
(*stabilityPlot=ListLinePlot[{#["Parameter"],#["MaxRealPart"]}&/@curve,AxesLabel->{"Parameter","Max Re(\[Lambda])"},PlotLabel->"Stability Analysis",PlotStyle->Blue,GridLines->{None,{0}},GridLinesStyle->Directive[Red,Dashed],ImageSize->400];*)
(*hopfPoints=Select[Table[Module[{prev,curr,next,prevReal,currReal,hasComplex},{prev,curr,next}={curve[[i-1]],curve[[i]],If[i<Length[curve],curve[[i+1]],curve[[i]]]};*)
(*{prevReal,currReal}={prev["MaxRealPart"],curr["MaxRealPart"]};*)
(*hasComplex=curr["ComplexPairs"]>0;*)
(*If[hasComplex&&prevReal*currReal<0,<|"parBif"->curr["Parameter"],"Type"->"Hopf"|>,Nothing]],{i,2,Length[curve]-1}],#=!=Nothing&];*)
(*hopfPoints];*)
(**)
(*(* =========================================================================*)*)
(*(*PARAMETER SCANNING*)*)
(*(* =========================================================================*)*)
(**)
(*scanPar[RHS_,var_,par_,p0val_,plotInd_,gridRes_:Automatic,plot_:Automatic,hTol_:0.01,delta_:1/20,wRan_:1,hRan_:1,R01_:Automatic,R02_:Automatic,R21_:Automatic,R12_:Automatic]:=Module[{betterColors,useGridMode,beta1Index,beta2Index,beta1Center,beta2Center,beta1min,beta1max,beta2min,beta2max,beta1vals,beta2vals,totalPoints,res,currentProgress,progressVar,tol,inP,numpar,conPar,sol,I1val,I2val,currentType,jac,eigs,maxRealPart,outcomes,outcomeCounts,finalPlot},betterColors={RGBColor[0,0,1],RGBColor[0,1,0],RGBColor[0.8,0.5,0.2],RGBColor[0.6,0.3,0.8],RGBColor[1,0,0],RGBColor[1.0,0.0,1.0]};*)
(*useGridMode=(gridRes=!=Automatic);*)
(*beta1Index=If[Length[plotInd]>=1,plotInd[[1]],1];*)
(*beta2Index=If[Length[plotInd]>=2,plotInd[[2]],2];*)
(*beta1Center=p0val[[beta1Index]];*)
(*beta2Center=p0val[[beta2Index]];*)
(*Print["Varying parameters at indices ",{beta1Index,beta2Index}," with center values: ",{beta1Center,beta2Center}];*)
(*If[useGridMode,Print["Using grid mode with ",gridRes,"x",gridRes," points..."];*)
(*beta1min=Max[beta1Center*(1-wRan),0.001];*)
(*beta1max=beta1Center*(1+wRan);*)
(*beta2min=Max[beta2Center*(1-hRan),0.001];*)
(*beta2max=beta2Center*(1+hRan);*)
(*beta1vals=Table[beta1min+(beta1max-beta1min)*k/(gridRes-1),{k,0,gridRes-1}];*)
(*beta2vals=Table[beta2min+(beta2max-beta2min)*k/(gridRes-1),{k,0,gridRes-1}];,Print["Using range mode with step size ",delta,"..."];*)
(*beta1min=Max[beta1Center*(1-wRan),0.001];*)
(*beta1max=beta1Center*(1+wRan);*)
(*beta2min=Max[beta2Center*(1-hRan),0.001];*)
(*beta2max=beta2Center*(1+hRan);*)
(*beta1vals=Table[beta1,{beta1,beta1min,beta1max,delta}];*)
(*beta2vals=Table[beta2,{beta2,beta2min,beta2max,delta}];];*)
(*totalPoints=Length[beta1vals]*Length[beta2vals];*)
(*Print["Total points to scan: ",totalPoints];*)
(*res={};*)
(*currentProgress=0;*)
(*progressVar=0;*)
(*tol=10^(-6);*)
(*inP=Table[{var[[j]],1/Length[var]},{j,Length[var]}];*)
(*Print[ProgressIndicator[Dynamic[progressVar]]];*)
(*(*Main scanning loop*)Do[Do[currentProgress++;*)
(*progressVar=N[currentProgress/totalPoints];*)
(*numpar=p0val;*)
(*numpar[[beta1Index]]=beta1;*)
(*numpar[[beta2Index]]=beta2;*)
(*conPar=Thread[par->numpar];*)
(*sol=Quiet[FindRoot[RHS/. conPar,inP]];*)
(*If[Head[sol]===List,{I1val,I2val}={var[[2]],var[[3]]}/. sol;(*Assuming I1,I2 are at positions 2,3*)currentType=Which[I1val<tol&&I2val<tol,"DFE",I1val>=tol&&I2val<tol,"E1",I1val<tol&&I2val>=tol,"E2",True,jac=D[RHS,{var}]/. conPar/. sol;*)
(*eigs=Chop[Eigenvalues[jac]//N];*)
(*maxRealPart=Max[Re[eigs]];*)
(*If[maxRealPart<0,"EEstable","EEunstable"]];*)
(*AppendTo[res,{N[beta1],N[beta2],currentType}];,AppendTo[res,{N[beta1],N[beta2],"NoSol"}];];,{beta2,beta2vals}];,{beta1,beta1vals}];*)
(*Print["Scanning complete!"];*)
(*outcomes=DeleteDuplicates[Table[res[[i,3]],{i,1,Length[res]}]];*)
(*outcomeCounts=Table[Count[res,{_,_,outcomes[[i]]}],{i,1,Length[outcomes]}];*)
(*finalPlot=ListPlot[Table[Select[res,#[[3]]==outcomes[[i]]&][[All,1;;2]],{i,Length[outcomes]}],PlotMarkers->Table[{Style["\[FilledCircle]",betterColors[[i]]],14},{i,Min[Length[betterColors],Length[outcomes]]}],PlotLegends->Table[outcomes[[i]]<>" ("<>ToString[outcomeCounts[[i]]]<>")",{i,Length[outcomes]}],AspectRatio->1,PlotLabel->"Parameter Space Analysis ("<>ToString[Length[res]]<>" points)",FrameLabel->{"Parameter "<>ToString[beta1Index],"Parameter "<>ToString[beta2Index]},ImageSize->450];*)
(*{finalPlot,{},res}];*)
(**)
(*(* =========================================================================*)*)
(*(*UTILITY FUNCTIONS*)*)
(*(* =========================================================================*)*)
(**)
(*pertIC[equilibrium_,var_,factor_:0.1,minq_:0.001,n_:1]:=Module[{eqVals,pertVals},eqVals=var/. equilibrium;*)
(*Table[pertVals=Max[#,minq]&/@(eqVals+factor*RandomReal[{-1,1},Length[var]]*Abs[eqVals]);*)
(*pertVals=pertVals(Total[eqVals]/Total[pertVals]);*)
(*Thread[var->pertVals],{n}]];*)
(**)
(*TS[RHS_,var_,par_,p0val_,tmax_:100]:=Module[{varT,initialConditions,rhsT,odeSystem,sol,solFun,coP,t},(*Create substitution rules*)coP=Thread[par->p0val];*)
(*(*Time-dependent variables*)varT=Through[var[t]];*)
(*(*Initial conditions using parameter values*)initialConditions=Thread[(varT/. t->0)==(var/. coP)];*)
(*(*RHS with substituted parameters and time variables*)rhsT=RHS/. Thread[var->varT]/. coP;*)
(*(*Full ODE system*)odeSystem=Join[Thread[D[varT,t]==rhsT],initialConditions];*)
(*(*Solve ODE system*)sol=Quiet@NDSolve[odeSystem,varT,{t,0,tmax},Method->{"BDF"}];*)
(*If[!MatchQ[sol,{(_Rule|_List)...}],Print["NDSolve failed"];*)
(*Return[$Failed];];*)
(*(*Extract solution functions*)solFun=#[[0]]&/@(varT/. sol[[1]]);*)
(*(*Return full solution functions*)solFun];*)
(**)
(*intEq[RHS_,var_,par_,p0val_,att_]:=Module[{eqs,sols,cleanSols,positiveSols,threshold=10^(-10),perturbedICs,attRules,coP},(*Create substitution rules*)coP=Thread[par->p0val];*)
(*eqs=Thread[RHS==0]/. coP;*)
(*(*Convert att list to replacement rules*)attRules=Thread[var->att];*)
(*(*Use attRules as seed instead of calling TS*)perturbedICs=Join[{var/. attRules},var/. #&/@pertIC[attRules,var,0.1,15],var/. #&/@pertIC[attRules,var,0.3,8]];*)
(*sols=Table[Quiet[FindRoot[eqs,Evaluate[Thread[{var,perturbedICs[[i]]}]],Method->"Newton"]],{i,1,Length[perturbedICs]}];*)
(*sols=Select[sols,Head[#]===List&&Length[#]==Length[var]&];*)
(*cleanSols=sols/. {x_?NumericQ:>If[Abs[x]<threshold,0,x]};*)
(*cleanSols=DeleteDuplicatesBy[cleanSols,Round[Sort[var/. #],10^(-6)]&];*)
(*positiveSols=Select[cleanSols,And@@(#>threshold&/@(var/. #))&];*)
(*Print["Found ",Length[positiveSols]," equilibria"];*)
(*positiveSols];*)
(**)
(*End[];*)
(*EndPackage[];*)
