(* ::Package:: *)

(* ::Input:: *)
(*(*EpidCRN Utils Subpackage-Utility functions and stability analysis*)BeginPackage["EpidCRN`Utils`",{"EpidCRN`Core`"}];*)
(**)
(*(* =========================================================================*)*)
(*(*ROUTH-HURWITZ STABILITY ANALYSIS*)*)
(*(* =========================================================================*)*)
(**)
(*Begin["`Private`"];*)
(**)
(*(* =========================================================================*)*)
(*(*ROUTH-HURWITZ IMPLEMENTATION*)*)
(*(* =========================================================================*)*)
(**)
(*CofRH[A_?MatrixQ]:=Module[{x},Drop[Reverse[CoefficientList[(-1)^(Length@A) CharacteristicPolynomial[A,x],x]],1]];*)
(**)
(*CofP[co_?ListQ]:=Drop[Reverse[(-1)^(Length@co)*co],1];*)
(**)
(*Hur2[co_]:=Module[{co3,ine},co3=co[[3]];*)
(*ine={co[[1]] co3>0,co[[2]] co3>0};*)
(*ine];*)
(**)
(*Hur3M[A_]:=Module[{co,h3,inec,ineSys,\[Omega]},co=CoefficientList[(-1)^Length[A] CharacteristicPolynomial[A,\[Omega]],\[Omega]];*)
(*h3=co[[2]]*co[[3]]-co[[1]]*co[[4]];*)
(*inec={co[[1]]>0,co[[2]]>0};*)
(*ineSys=Append[inec,h3>0];*)
(*{co,h3,ineSys}];*)
(**)
(*Hur4M[mat_]:=Module[{lm,ch,cot,co,H4,h4,ine},lm=mat//Length;*)
(*ch=((-1)^lm*CharacteristicPolynomial[mat,\[Lambda]]//Factor);*)
(*cot=CoefficientList[ch,\[Lambda]];*)
(*co=Reverse[Drop[cot,-1]];*)
(*H4={{co[[1]],1,0,0},{co[[3]],co[[2]],co[[1]],1},{0,co[[4]],co[[3]],co[[2]]},{0,0,0,co[[4]]}};*)
(*h4=Det[H4];*)
(*ine=Thread[co>0];*)
(*{co,h4,ine}];*)
(**)
(*Hur5M[jac_]:=Module[{lm,ch,cot,co,H5,h5,ine},lm=jac//Length;*)
(*ch=((-1)^lm*CharacteristicPolynomial[jac,\[Lambda]]//Factor);*)
(*cot=CoefficientList[ch,\[Lambda]];*)
(*co=Reverse[Drop[cot,-1]];*)
(*H5={{co[[1]],1,0,0,0},{co[[3]],co[[2]],co[[1]],1,0},{co[[5]],co[[4]],co[[3]],co[[2]],co[[1]]},{0,0,co[[5]],co[[4]],co[[3]]},{0,0,0,0,co[[5]]}};*)
(*h5=Det[H5];*)
(*ine=Append[Thread[co>0],co[[1]] co[[2]]>co[[3]]];*)
(*{co,h5,ine,H5}];*)
(**)
(*H4[co_]:={{co[[1]],1,0,0},{co[[3]],co[[2]],co[[1]],1},{0,co[[4]],co[[3]],co[[2]]},{0,0,0,co[[4]]}};*)
(**)
(*H6[co_]:=Module[{hm},hm={{co[[1]],1,0,0,0,0},{co[[3]],co[[2]],co[[1]],1,0,0},{co[[5]],co[[4]],co[[3]],co[[2]],co[[1]],1},{0,co[[6]],co[[5]],co[[4]],co[[3]],co[[2]]},{0,0,0,co[[6]],co[[5]],co[[4]]},{0,0,0,0,0,co[[6]]}};*)
(*Det[hm]];*)
(**)
(*(* =========================================================================*)*)
(*(*MATRIX UTILITIES*)*)
(*(* =========================================================================*)*)
(**)
(*makeLPM[mat_]:=Table[Det@mat[[1;;i,1;;i]],{i,1,Length@mat}];*)
(**)
(*ACM[matrix_,k_]:=D[Minors[IdentityMatrix[Length@matrix]+t*matrix,k],t]/. t->0;*)
(**)
(*perR[M_,i_,j_]:=ReplacePart[M,{i->M[[j]],j->M[[i]]}];*)
(**)
(*perC[matrix_,cycle_List]:=Module[{tempMatrix=matrix},tempMatrix[[cycle]]=tempMatrix[[RotateRight[cycle]]];*)
(*tempMatrix];*)
(**)
(*(* =========================================================================*)*)
(*(*STABILITY ANALYSIS*)*)
(*(* =========================================================================*)*)
(**)
(*Stab[mod_,cfp_,cn_:{}]:=Module[{dyn,X,par,jac,jacfp,eig},dyn=mod[[1]];*)
(*X=mod[[2]];*)
(*par=mod[[3]];*)
(*jac=Grad[dyn,X];*)
(*jacfp=jac//.cfp;*)
(*eig=Eigenvalues[jacfp/. cn]];*)
(**)
(*Sta[jac_,X_,Xv_]:=Map[Max[Re[Eigenvalues[jac/. Thread[X->#]]]]&,Xv];*)
(**)
(*JTD[mod_,cn_:{}]:=Module[{dyn,X,jac,tr,det},dyn=mod[[1]];*)
(*X=mod[[2]];*)
(*jac=Grad[dyn,X]/. cn;*)
(*tr=Tr[jac];*)
(*det=Det[jac];*)
(*{jac,tr,det}];*)
(**)
(*JTDP[mod_,\[Zeta]_:\[Zeta],cn_:{}]:=Module[{dyn,X,jac,tr,det,chp,cof},dyn=mod[[1]];*)
(*X=mod[[2]];*)
(*jac=Grad[dyn,X]/. cn;*)
(*tr=Tr[jac];*)
(*det=Det[jac];*)
(*chp=CharacteristicPolynomial[jac,\[Zeta]];*)
(*cof=CoefficientList[chp,\[Zeta]];*)
(*{jac,tr,det,cof,chp}];*)
(**)
(*(* =========================================================================*)*)
(*(*CONVERSION UTILITIES*)*)
(*(* =========================================================================*)*)
(**)
(*mat2Matl[matrix_List]:=Module[{matStr},matStr=StringJoin[Riffle[StringJoin[Riffle[ToString/@#," "]]&/@matrix,"; "]];*)
(*StringJoin["[",matStr,"]"]];*)
(**)
(*matl2Mat[matrix_String]:=Module[{formattedMatrix},formattedMatrix=StringSplit[matrix,"\n"];*)
(*formattedMatrix=StringReplace[formattedMatrix,Whitespace..->" "];*)
(*formattedMatrix=StringReplace[#," "->", "]&/@formattedMatrix;*)
(*formattedMatrix="{"<>#<>"}"&/@formattedMatrix;*)
(*formattedMatrix="{"<>StringRiffle[formattedMatrix,",\n"]<>"}";*)
(*ToExpression[formattedMatrix]];*)
(**)
(*matlr2Mat[str_String]:=Module[{formattedString,result},formattedString=StringReplace[str,{"{"->"","}"->"","["->"","]"->""}];*)
(*formattedString=StringSplit[formattedString," "];*)
(*result=ToExpression[formattedString];*)
(*DeleteCases[result,Null]];*)
(**)
(*toSum=(#/. Times->Plus)&;*)
(*toProd=(#/. Plus->Times)&;*)
(*l2L=#&; (*Identity function placeholder*)*)
(*m2toM=#&; (*Identity function placeholder*)*)
(**)
(*(* =========================================================================*)*)
(*(*GENERAL UTILITIES*)*)
(*(* =========================================================================*)*)
(**)
(*remZ[li_]:=Select[li,#=!=0&];*)
(**)
(*rtS[RHS_List]:=DeleteDuplicates[Flatten[MonomialList/@Expand[RHS]]/. -1*x_:>x];*)
(**)
(*albe[RHS_,var_]:=Module[{rts,nvar,nrts,al,be,ga,i,j,rate,coeff},rts=rtS[RHS];*)
(*nvar=Length[var];*)
(*nrts=Length[rts];*)
(*al=ConstantArray[0,{nvar,nrts}];*)
(*be=ConstantArray[0,{nvar,nrts}];*)
(*Do[Do[al[[i,j]]=Exponent[rts[[j]],var[[i]]],{i,nvar}];,{j,nrts}];*)
(*Do[Do[rate=rts[[j]];*)
(*coeff=Coefficient[RHS[[i]],rate];*)
(*be[[i,j]]=al[[i,j]]+coeff;,{j,nrts}];,{i,nvar}];*)
(*ga=be-al;*)
(*{al,be,ga,rts}];*)
(**)
(*RHS2RN[RHS_,var_]:=Module[{al,be,ga,spe,lhs,rhs,RN,rts},{al,be,ga,rts}=albe[RHS,var];*)
(*spe=Symbol[ToUpperCase[ToString[#]]]&/@var;*)
(*lhs=spe . al;*)
(*rhs=spe . be;*)
(*lhs=lhs/. {x_+0:>x,0+x_:>x,0*_:>0};*)
(*rhs=rhs/. {x_+0:>x,0+x_:>x,0*_:>0};*)
(*RN=Thread[lhs->rhs];*)
(*{RN,rts,ga}];*)
(**)
(*selZR[con_]:=Select[con,MatchQ[#,Rule[_,0]]&];*)
(**)
(*red[re_,cond_:{}]:=re/. (#->True&/@cond);*)
(**)
(*reCL[re_]:=DeleteCases[re,_Symbol>0|Subscript[_,__]>0,Infinity];*)
(**)
(*seZF[expr_]:=Select[expr,FreeQ[#,0]&];*)
(**)
(*onePR[cof_,cp_:{}]:=Append[cp,(cof[[#]]//First) (cof[[#]]//Last)<0]&/@Range[cof//Length];*)
(**)
(*expon:=Exponent[#,Variables[#]]&;*)
(**)
(*posM=Replace[#,{_?Negative->0,e_:>Replace[Expand[e],{Times[_?Negative,_]->0,t_Plus:>Replace[t,_?Negative|Times[_?Negative,_]->0,1]}]},{2}]&;*)
(**)
(*FposEx=With[{pos=First@SparseArray[#]["NonzeroPositions"]},SparseArray[{pos->Extract[#,pos]},Dimensions@#]]&;*)
(**)
(*onlyP[m_]:=m//Together//NumeratorDenominator//Map@CoefficientArrays//ReplaceAll[sa_SparseArray:>sa["NonzeroValues"]]//Flatten//AllTrue[#,NonNegative]&;*)
(**)
(*CreateMassActionRate[reactants_Association,kParam_]:=kParam*Product[reactants[spec]^coeff,{spec,Keys[reactants]},{coeff,Values[reactants]}];*)
(**)
(*Par[RHS_,X_]:=Complement[Variables[RHS],X];*)
(**)
(*strEdg[edges_List]:=Map[ToString,edges,{2}];*)
(**)
(*countMS[m_]:=m//Together//NumeratorDenominator//Map@CoefficientArrays//ReplaceAll[sa_SparseArray:>sa["NonzeroValues"]]//Flatten//Count[#,_?Negative]&;*)
(**)
(*convNum[vertices_List]:=Module[{basis,processTerm,parseVertex},basis=Association[{"A"->{1,0},"B"->{0,1}}];*)
(*processTerm[term_]:=Module[{coef,letter},{coef,letter}=StringCases[term,{a:DigitCharacter..~~" "~~l:("A"|"B"):>{ToExpression[a],l},l:("A"|"B"):>{1,l}}][[1]];*)
(*coef*basis[letter]];*)
(*parseVertex[vertex_String]:=Total[processTerm/@StringSplit[vertex," + "]];*)
(*parseVertex/@vertices];*)
(**)
(*(* =========================================================================*)*)
(*(*POLYNOMIAL AND ALGEBRAIC TOOLS*)*)
(*(* =========================================================================*)*)
(**)
(*Grobpol[RHS_,var_,par_,ind_,cn_:{}]:=Module[{li,pa},li={pol,sc};*)
(*pa=Complement[Variables[li],{var}];*)
(*GroebnerBasis[{Numerator[Together[pol]],Numerator[Together[sc]]}/. cn,pa,{var},MonomialOrder->EliminationOrder]];*)
(**)
(*RUR[mod_,ind_:{1},cn_:{}]:=Module[{RHS,var,par,elim,ratsub,pol,rat1},RHS=mod[[1]]/. cn;*)
(*var=mod[[2]];*)
(*par=mod[[3]];*)
(*elim=Complement[Range[Length[var]],ind];*)
(*ratsub=seZF[Solve[Delete[Thread[RHS==0],ind],var[[elim]]]];*)
(*pol=Numerator[Together[RHS//.ratsub]];*)
(*RHS[[ind]]/. ratsub;*)
(*rat1=Append[(ratsub/. var[[ind]]->1),var[[ind]]->1];*)
(*{ratsub,pol,rat1}];*)
(**)
(*GBH[pol_,var_,sc_,cn_:{}]:=Module[{li,pa},li={pol,sc};*)
(*pa=Complement[Variables[li],{var}];*)
(*GroebnerBasis[{Numerator[Together[pol]],Numerator[Together[sc]]}/. cn,pa,{var},MonomialOrder->EliminationOrder]];*)
(**)
(*Stodola[pol_,var_]:=Equal@@Sign[CoefficientList[pol,var]];*)
(**)
(*L1Planar[fg_,var_,equilcon_:{}]:=Module[{J,xyshift,Tm,Tinvuv,FG,derivatives,a,b,i,j,L1,x,y,F,G,normForm},{x,y}=var;*)
(*J=Simplify[D[fg,{var}]/. equilcon];*)
(*xyshift={x->x+(x/. equilcon),y->y+(y/. equilcon)};*)
(*Tm={{1,0},{-a/Global`ome,-b/Global`ome}};*)
(*Tinvuv=Inverse[Tm] . {Global`u,Global`v};*)
(*FG=(Tm . fg/. xyshift)/. {x->Tinvuv[[1]],y->Tinvuv[[2]]}/. {a->J[[1,1]],b->J[[1,2]]};*)
(*derivatives={};*)
(*For[i=0,i<=3,i++,For[j=0,j<=3-i,j++,derivatives=Join[derivatives,{Subscript[F,i,j]->(D[FG[[1]],{Global`u,i},{Global`v,j}]/. {Global`u->0,Global`v->0}),Subscript[G,i,j]->(D[FG[[2]],{Global`u,i},{Global`v,j}]/. {Global`u->0,Global`v->0})}]]];*)
(*L1=Subscript[F,3,0]+Subscript[F,1,2]+Subscript[G,0,3]+Subscript[G,2,1]+1/Global`ome*(Subscript[F,1,1]*(Subscript[F,2,0]+Subscript[F,0,2])-Subscript[G,1,1]*(Subscript[G,2,0]+Subscript[G,0,2])+Subscript[F,0,2]*Subscript[G,0,2]-Subscript[F,2,0]*Subscript[G,2,0]);*)
(*L1=L1/. derivatives;*)
(*F1=Sum[Subscript[F,i,j] Global`u^i Global`v^j,{i,0,3},{j,0,3-i}];*)
(*G1=Sum[Subscript[G,i,j] Global`u^i Global`v^j,{i,0,3},{j,0,3-i}];*)
(*normForm={F1,G1}/. derivatives;*)
(*{L1,FG,normForm}];*)
(**)
(*DerEq[f_,var_,equilcon_]:=Module[{derivatives,order,deriv,i,j,k,A,B,CC,DD,EE,x,y,z,par,cp},n=Length[f];*)
(*A=D[f,{var}]/. equilcon;*)
(*{x,y,z}=var;*)
(*par=Par[f,var];*)
(*cp=Thread[par>0];*)
(*derivatives={};*)
(*order=2;*)
(*For[i=0,i<=order,i++,For[j=0,j<=order-i,j++,For[k=0,k<=order-i-j,k++,deriv=Simplify[D[f,{x,i},{y,j},{z,k}]/. equilcon];*)
(*derivatives=Join[derivatives,Simplify[{Subscript[F,i,j,k]->deriv[[1]],Subscript[G,i,j,k]->deriv[[2]],Subscript[H,i,j,k]->deriv[[3]]}]];]]];*)
(*B[x_,y_]:=Sum[{Subscript[F,Idx[{k,l},n]],Subscript[G,Idx[{k,l},n]],Subscript[H,Idx[{k,l},n]]}x[[k]]y[[l]]/. derivatives,{k,n},{l,n}];*)
(*CC[x_,y_,z_]:={0,0,0};*)
(*DD[x_,y_,z_,s_]:={0,0,0};*)
(*EE[x_,y_,z_,s_,t_]:={0,0,0};*)
(*{A,B,CC}];*)
(**)
(*(* =========================================================================*)*)
(*(*SPECIALIZED ANALYSIS FUNCTIONS*)*)
(*(* =========================================================================*)*)
(**)
(*GetVec[A_,om_]:=Module[{n,mtx,pconj,q,qconj,normalize},n=Length[A];*)
(*mtx=A-om I IdentityMatrix[n];*)
(*q=NullSpace[mtx[[Range[1,n-1]]]][[1]];*)
(*mtx=A\[Transpose]-om I IdentityMatrix[n];*)
(*pconj=NullSpace[mtx[[Range[1,n-1]]]][[1]];*)
(*normalize=FullSimplify[pconj . q];*)
(*pconj=pconj/normalize;*)
(*qconj=FullSimplify[ComplexExpand[q\[Conjugate]]];*)
(*{pconj,q,qconj}];*)
(**)
(*L13[A_,B_,CC_,cp_]:=Module[{n,pconj,q,qconj,v1,v2,v3,c1,numer,denom,a,b,c,d,L1\[Kappa]\[Omega]},n=Length[A];*)
(*{pconj,q,qconj}=GetVec[A,ome];*)
(*v1=CC[q,q,qconj];*)
(*v2=B[q,Inverse[-A] . B[q,qconj]];*)
(*v3=B[qconj,Inverse[2 I ome IdentityMatrix[n]-A] . B[q,q]];*)
(*c1=pconj . (1/2 v1+v2+1/2 v3);*)
(*numer=Numerator[c1];*)
(*denom=Denominator[c1];*)
(*a=Simplify[ComplexExpand[Re[numer]],cp];*)
(*b=Simplify[ComplexExpand[Im[numer]],cp];*)
(*c=Simplify[ComplexExpand[Re[denom]],cp];*)
(*d=Simplify[ComplexExpand[Im[denom]],cp];*)
(*L1\[Kappa]\[Omega]=Simplify[(a c+b d)/(c^2+d^2)]];*)
(**)
(*L23[A_,B_,CC_:{0,0,0},DD_:{0,0,0},EE_:{0,0,0}]:=Module[{n,Id,omega,invA,inv2,inv3,pconj,q,qconj,h,prec,c,invbig},n=Length[A];*)
(*Id=IdentityMatrix[n];*)
(*omega=Sqrt[Det[A]/Tr[A]];*)
(*invA=Inverse[A];*)
(*inv2=Simplify[Inverse[2 omega I Id-A]];*)
(*inv3=Simplify[Inverse[3 omega I Id-A]];*)
(*{pconj,q,qconj}=GetVec[A,omega];*)
(*q=FullSimplify[q/. {\[Omega]->omega}];*)
(*pconj=FullSimplify[pconj/. {\[Omega]->omega}];*)
(*(*Simplified implementation-full L23 calculation would be quite long*)ComplexExpand[Re[c]]];*)
(**)
(*Res1F[mod_,csr_,pol_,in_,cn_:{}]:=Module[{jac,det,res,chp,cof},jac=JTDP[mod][[1]]/. csr/. cn;*)
(*det=Numerator[Together[Det[jac]]];*)
(*res=Resultant[det,pol,in]//Factor];*)
(**)
(*Deg[poly_,var_]:=Exponent[poly,var];*)
(**)
(*Hirono[S_,intRows_,intCols_]:=Module[{S11,S12,S21,S22,S11plus,Sred},S11=S[[intRows,intCols]];*)
(*S12=S[[intRows,Complement[Range[Dimensions[S][[2]]],intCols]]];*)
(*S21=S[[Complement[Range[Dimensions[S][[1]]],intRows],intCols]];*)
(*S22=S[[Complement[Range[Dimensions[S][[1]]],intRows],Complement[Range[Dimensions[S][[2]]],intCols]]];*)
(*S11plus=PseudoInverse[S11];*)
(*Sred=Simplify[S22-S21 . S11plus . S12];*)
(*Sred];*)
(**)
(*DerL[expr_]:=D[expr,#]&/@Variables[expr];*)
(**)
(*(*Placeholder for missing function*)*)
(*Idx[set_,n_PositiveInteger]:=Module[{seq},seq=(Table[Count[set,i],{i,n}]/. List->Sequence);*)
(*seq];*)
(**)
(*End[];*)
(*EndPackage[];*)
